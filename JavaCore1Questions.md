Java Core вопросы
1. Что такое объектно-ориентированное программирование (ООП)?
2. Каковы преимущества использования ООП?
3. Какие недостатки существуют у ООП?
4. Назовите основные принципы ООП.
5. Что представляет собой инкапсуляция в контексте ООП?
6. Как работает наследование в Java?
7. Что такое полиморфизм в Java?
8. Как определяется ассоциация между классами?
9.  Что представляет собой композиция?
10. Что такое агрегация в контексте ООП?
11. Расскажите о раннем и позднем связывании в Java.
12. Что означает принцип SOLID?
13. Какая основная идея языка Java?
14. Как достигается кросс-платформенность в Java?
15. Каковы преимущества использования Java?
16. Какие недостатки существуют у языка Java?
17. Что представляет собой JDK (Java Development Kit)? Какие компоненты входят в JDK?
18. Что такое JRE (Java Runtime Environment)? Какие компоненты входят в JRE?
19. Что такое JVM (Java Virtual Machine)?
20. Что такое байт-код (byte code)?
21. Что представляет собой загрузчик классов (classloader) в Java?
22. Что такое JIT (Just-In-Time) компиляция?
23. Что такое сборщик мусора (Garbage collector)?
24. Как работает сборщик мусора?
25. Какие основные стратегии сборки мусора существуют?
26. Что представляет собой "корень" (root) в контексте сборки мусора?
27. Что такое "Stop-the-World" событие в контексте сборки, и почему оно является важным аспектом для разработчиков?
28. Какие области памяти используются в сборке мусора в Java, и каково их назначение?
29. Расскажите о различных поколениях памяти в Java. Как они взаимодействуют в процессе сборки мусора?
30. Каковы основные виды сборок мусора в Java, и что представляют собой сборки мусора типа minor, major и full?
31. Какие типы ссылок существуют, и как они влияют на сборку мусора?
32. Какие объекты считаются "достижимыми" и "недостижимыми" для сборщика мусора?
33. Какие проблемы может вызвать утечка памяти (memory leak), и как их предотвратить?
34. В чем состоит преимущество использования различных сборщиков мусора?
35. Расскажите о работе Serial Garbage Collector. В каких случаях он может быть полезен?
36. Что представляет собой Parallel Garbage Collector? Какие преимущества он предоставляет?
37. Как функционирует CMS Garbage Collector (Concurrent Mark-Sweep)? Какие проблемы сборщика мусора CMS могут возникнуть?
38. Как работает Garbage-First (G1) Garbage Collector? В чем его особенности и преимущества?
39. Каковы преимущества использования G1 Garbage Collector в сравнении с традиционными сборщиками мусора, такими как CMS или Parallel GC?
40. Что представляет собой Z Garbage Collector (ZGC)? В каких случаях его использование может быть выгодным?
41. Какие проблемы решает Shenandoah Garbage Collector, и как он работает?
42. В чем различие между стеком (Stack) и кучей (Heap)?
43. Какие примитивные типы данных существуют? (Вопрос на дурака, отвечаем без нервов)
44. Что такое тип данных char?
45. Сколько памяти занимает переменная типа boolean?
46. Что такое классы-обертки?
47. Что представляют собой автоупаковка и автораспаковка?
48. Что означают явное и неявное приведение типов? В каких случаях используется явное приведение?
49. Что такое пул интов (int pool)?
50. Какие особенности связаны со строками?
51. Что представляет собой пул строк?
52. Почему не рекомендуется изменять строки в цикле? Какое решение предпочтительно использовать?
53. Почему строки не рекомендуется использовать для хранения паролей?
54. Почему класс String является неизменяемым и финализированным?
55. Почему строки часто используются в качестве ключей в HashMap?
56. Какую роль выполняет метод intern() в классе String?
57. Можно ли использовать строки в конструкции switch?
58. Какова основная разница между String, StringBuffer и StringBuilder?
59. Существуют ли в Java многомерные массивы?
60. Какими значениями инициализируются переменные по умолчанию в Java?
61. Что представляет собой сигнатура метода?
62. Расскажите о методе main в Java.
63. Как передаются переменные в методы в Java - по значению или по ссылке?
64. Какие виды классов существуют в Java?
65. Расскажите о вложенных классах и в каких случаях они применяются?
66. Что такое "локальный класс" и каковы его особенности?
67. Что представляют собой "анонимные классы" и где они применяются?
68. Как из вложенного класса получить доступ к полю внешнего класса?
69. Что такое перечисления (enum) в Java?
70. Как в Java решена проблема ромбовидного наследования?
71. Что представляет собой конструктор по умолчанию?
72. Могут ли быть приватные конструкторы и для чего они нужны?
73. Расскажите о классах-загрузчиках и динамической загрузке классов в Java.
74. В чем различие между конструктором по умолчанию, конструктором копирования и конструктором с параметрами?
75. Какие модификаторы доступа существуют в Java и какие из них применимы к классам?
76. Что означает модификатор static в Java?
77. Может ли статический метод быть переопределен или перегружен?
78. Могут ли нестатические методы перегрузить статические методы?
79. Можно ли сузить уровень доступа или тип возвращаемого значения при переопределении метода?
80. Что можно изменить в сигнатуре метода при переопределении, и можно ли менять модификаторы (throws и т.д.)?
81. Могут ли классы быть статическими в Java?
82. Что означает модификатор final и к чему он может быть применен?
83. Что такое абстрактные классы в Java и в чем их отличие от обычных классов?
84. Может ли абстрактный класс существовать без абстрактных методов?
85. Могут ли быть конструкторы у абстрактных классов и для чего они нужны?
86. Что представляют собой интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?
87. В чем различие между интерфейсами и абстрактными классами в Java? В каких случаях использовать абстрактные классы, а в каких интерфейсы?
88. Может ли один интерфейс наследоваться от другого, и может ли наследоваться от двух других?
89. Что представляют собой дефолтные методы интерфейсов и для чего они нужны?
90. Как решается проблема ромбовидного наследования при наследовании интерфейсов с дефолтными методами?
91. Каков порядок вызова конструкторов и блоков инициализации с учетом иерархии классов?
92. Зачем нужны и какие бывают блоки инициализации?
93. Для чего используются статические блоки инициализации?
94. Что произойдет, если в блоке инициализации возникнет исключение?
95. Какое исключение выбрасывается при ошибке в блоке инициализации класса в Java?
96. Каково предназначение класса Object в Java?
97. Какие методы доступны в классе Object, и что они выполняют? Перечислите все методы.
98. Концепция equals() и hashcode() в Java.
99.  Как реализованы методы hashCode() и equals() в классе Object?
100. Для чего используется метод equals()? Как он отличается от операции ==?
101. Каковы основные правила для переопределения метода equals()?
102. Какие проблемы могут возникнуть, если переопределить equals() без переопределения hashCode()? Как этого избежать?
103. Как связаны между собой методы hashCode() и equals()? Существует ли контракт между ними?
104. Зачем нужен метод hashCode() в Java?
105. Какие правила следует соблюдать при переопределении метода hashCode()?
106. Существуют ли рекомендации по использованию конкретных полей при реализации hashCode()?
107. Могут ли у различных объектов быть одинаковые значения hashCode()?
108. Почему невозможно создать уникальный hashCode() для каждого объекта?
109. Почему предпочтительнее использовать хэш-код в виде 31 * x + y, а не x + y?
110. Как отличается a.getClass().equals(A.class) от операции a instanceof A.class?
111. Что представляют собой исключения в Java?
112. Опишите иерархию исключений.
113. Чем отличаются обрабатываемые и необрабатываемые исключения?
114. Возможно ли обработать необрабатываемые исключения?
115. Какой оператор позволяет явно выбросить исключение?
116. Какое значение несет ключевое слово throws?
117. Как создать собственное исключение?
118. Расскажите о механизме обработки исключений с использованием try-catch-finally.
119. Возможно ли использовать блок try-finally без блока catch?
120. Может ли один блок catch обрабатывать несколько различных исключений?
121. Всегда ли выполняется блок finally? Есть ли ситуации, когда блок finally не будет выполнен?
122. Может ли метод main() выбросить исключение за пределы программы, и если да, где будет обработано это исключение?
123. В каком порядке следует обрабатывать исключения в блоках catch?
124. Что такое механизм try-with-resources?
125. Каков результат, если исключение выбрасывается из блока catch, за которым следует другое исключение из блока finally?
126. Каков результат, если исключение выбрасывается из блока catch, за которым следует исключение из метода close() при использовании try-with-resources?
127. Что представляет собой сериализация, и как она реализована в Java?
128. Для чего нужна сериализация?
129. Опишите процесс сериализации/десериализации с использованием интерфейса Serializable.
130. Как можно изменить стандартное поведение сериализации/десериализации?
131. Какие поля не будут сериализованы при использовании Serializable? Будет ли сериализовано final поле?
132. Как можно создать собственный протокол сериализации?
133. Какую роль играет поле serialVersionUID в процессе сериализации?
134. Когда следует изменять значение поля serialVersionUID?
135. В чем заключается проблема сериализации Singleton?
136. Расскажите о клонировании объектов.
137. В чем разница между поверхностным и глубоким клонированием?
138. Какой метод клонирования предпочтителен?
139. Почему метод clone() объявлен в классе Object, а не в интерфейсе Cloneable?
140. Как можно создать глубокую копию объекта?
