# 1. Что такое DDL? Какие операции в него входят?

**DDL (Data Definition Language)** ? это подмножество языка SQL, используемое для определения и управления структурами базы данных, такими как таблицы, индексы, представления и другие объекты. Основная задача DDL ? создание, изменение и удаление схем базы данных и ее объектов. В отличие от других типов SQL-запросов, таких как DML (Data Manipulation Language), которые изменяют данные, DDL работает с метаданными и структурой самой базы данных.

## Основные операции DDL

В DDL входят следующие основные команды:

1. **CREATE** ? создание объектов базы данных.
2. **ALTER** ? изменение структуры существующих объектов базы данных.
3. **DROP** ? удаление объектов базы данных.
4. **TRUNCATE** ? удаление всех данных из таблицы без удаления самой таблицы.
5. **RENAME** ? изменение имени объектов базы данных (например, таблиц).

### 1. CREATE

Команда **CREATE** используется для создания новых объектов базы данных, таких как таблицы, индексы, представления, процедуры и схемы.

#### Пример создания таблицы:

```sql
CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY,
    FirstName VARCHAR(50),
    LastName VARCHAR(50),
    BirthDate DATE,
    Salary DECIMAL(10, 2)
);
```

### Объяснение:

- **CREATE TABLE Employees** ? создает таблицу с именем `Employees`.
- **EmployeeID INT PRIMARY KEY** ? создает столбец `EmployeeID` типа `INT` и делает его первичным ключом.
- Остальные столбцы определяются с соответствующими типами данных.

### 2. ALTER

Команда **ALTER** используется для изменения структуры уже существующих объектов базы данных. Она позволяет добавлять, изменять или удалять столбцы в таблицах, а также изменять другие свойства объектов.

#### Примеры использования:

- **Добавление столбца:**

```sql
ALTER TABLE Employees ADD Email VARCHAR(100);
```

- **Изменение типа данных столбца:**

```sql
ALTER TABLE Employees MODIFY Salary DECIMAL(15, 2);
```

- **Удаление столбца:**

```sql
ALTER TABLE Employees DROP COLUMN BirthDate;
```

### 3. DROP

Команда **DROP** используется для удаления объектов базы данных. В отличие от команды `DELETE`, которая удаляет данные, `DROP` удаляет всю структуру объекта.

#### Пример удаления таблицы:

```sql
DROP TABLE Employees;
```

### Объяснение:

- Эта команда удаляет таблицу `Employees` из базы данных вместе со всей ее структурой и данными.

### 4. TRUNCATE

Команда **TRUNCATE** удаляет все строки из таблицы, но сохраняет структуру таблицы для дальнейшего использования. Она работает быстрее, чем `DELETE`, так как не ведет запись в журнал транзакций для каждой удаляемой строки.

#### Пример использования:

```sql
TRUNCATE TABLE Employees;
```

### Объяснение:

- Все данные из таблицы `Employees` будут удалены, но сама таблица остается. Структура таблицы сохраняется, и счетчики автоинкремента сбрасываются.

### 5. RENAME

Команда **RENAME** используется для переименования объектов базы данных, например, таблиц или индексов.

#### Пример переименования таблицы:

```sql
ALTER TABLE Employees RENAME TO Staff;
```

### Объяснение:

- Таблица `Employees` будет переименована в `Staff`.

## Особенности DDL

1. **Автоматическая фиксация (Autocommit):** DDL-команды автоматически фиксируются в базе данных после выполнения, и откатить их невозможно (без использования резервного копирования).

2. **Изменение структуры:** Основное предназначение DDL ? изменение схемы базы данных, а не данных. Операции DDL могут изменить структуру таблиц, схем и других объектов.

3. **Модификация индексов и связей:** С помощью DDL можно управлять индексами, внешними ключами и другими связями между таблицами.

4. **Блокировки:** В большинстве систем управления базами данных (СУБД) операции DDL могут блокировать таблицы, чтобы избежать конфликтов во время изменения структуры.

## Заключение

**DDL** ? это мощный инструмент для управления структурой базы данных. Основные команды DDL (`CREATE`, `ALTER`, `DROP`, `TRUNCATE`, `RENAME`) позволяют разработчикам создавать и модифицировать объекты базы данных, а также управлять их жизненным циклом. Понимание DDL является ключевым для эффективного проектирования и администрирования баз данных.

# 2. Что такое DML? Какие операции в него входят?

**DML (Data Manipulation Language)** ? это подмножество языка SQL, предназначенное для работы с данными внутри объектов базы данных, таких как таблицы. DML-команды используются для выполнения операций добавления, обновления, удаления и выборки данных. В отличие от DDL, которое работает со структурой базы данных, DML оперирует непосредственно данными, находящимися в этих структурах.

## Основные операции DML

К основным операциям DML относятся следующие команды:

1. **SELECT** ? выборка данных из базы данных.
2. **INSERT** ? добавление новых записей в таблицу.
3. **UPDATE** ? обновление существующих записей в таблице.
4. **DELETE** ? удаление записей из таблицы.

### 1. SELECT

Команда **SELECT** используется для извлечения данных из одной или нескольких таблиц. Это наиболее часто используемая команда SQL, которая позволяет фильтровать, сортировать и агрегировать данные по определенным условиям.

#### Пример использования:

```sql
SELECT FirstName, LastName, Salary
FROM Employees
WHERE Salary > 50000
ORDER BY Salary DESC;
```

### Объяснение:

- **SELECT FirstName, LastName, Salary** ? выбирает столбцы `FirstName`, `LastName` и `Salary`.
- **FROM Employees** ? указывает, что данные берутся из таблицы `Employees`.
- **WHERE Salary > 50000** ? фильтрует данные, выбирая только записи с зарплатой выше 50,000.
- **ORDER BY Salary DESC** ? сортирует результаты по зарплате в порядке убывания.

### 2. INSERT

Команда **INSERT** добавляет новые строки в таблицу. Она позволяет вставлять данные как для всех столбцов таблицы, так и для выбранных столбцов.

#### Пример вставки данных:

```sql
INSERT INTO Employees (FirstName, LastName, BirthDate, Salary)
VALUES ('John', 'Doe', '1980-05-15', 60000);
```

### Объяснение:

- **INSERT INTO Employees (FirstName, LastName, BirthDate, Salary)** ? указывает таблицу и столбцы, в которые будут вставлены данные.
- **VALUES ('John', 'Doe', '1980-05-15', 60000)** ? указывает значения для вставки в соответствующие столбцы.

#### Пример вставки с указанием всех столбцов:

```sql
INSERT INTO Employees
VALUES (1, 'Jane', 'Smith', '1990-07-20', 55000);
```

- Здесь перечислены все значения для вставки во все столбцы в порядке их определения в таблице.

### 3. UPDATE

Команда **UPDATE** используется для изменения существующих данных в одной или нескольких строках таблицы. Она позволяет изменять значения столбцов на основе условий, определяемых в `WHERE`-классе.

#### Пример обновления данных:

```sql
UPDATE Employees
SET Salary = Salary * 1.1
WHERE LastName = 'Doe';
```

### Объяснение:

- **UPDATE Employees** ? указывает, что изменения вносятся в таблицу `Employees`.
- **SET Salary = Salary * 1.1** ? обновляет значение столбца `Salary`, увеличивая его на 10%.
- **WHERE LastName = 'Doe'** ? применяет изменения только к записям, у которых фамилия `Doe`.

### 4. DELETE

Команда **DELETE** удаляет строки из таблицы на основе заданных условий. Важно отметить, что `DELETE` удаляет только данные, но не саму структуру таблицы.

#### Пример удаления данных:

```sql
DELETE FROM Employees
WHERE Salary < 30000;
```

### Объяснение:

- **DELETE FROM Employees** ? указывает таблицу, из которой будут удалены данные.
- **WHERE Salary < 30000** ? удаляет записи с зарплатой ниже 30,000. Если условие `WHERE` не указано, будут удалены все строки таблицы.

## Особенности DML

1. **Транзакционность:** Команды DML могут быть частью транзакций, что позволяет контролировать внесение изменений и выполнять откаты в случае ошибок. Например, если в процессе выполнения нескольких DML-команд что-то пошло не так, можно отменить изменения с помощью команды `ROLLBACK`.

2. **Изменение данных, а не структуры:** В отличие от DDL, который управляет структурой базы данных, DML работает непосредственно с данными, обеспечивая добавление, изменение, удаление и выборку записей.

3. **Изменения с фиксацией:** DML-команды обычно требуют явной или неявной фиксации (`COMMIT`), чтобы изменения вступили в силу. Без фиксации внесенные изменения могут быть откатаны.

4. **Воздействие на производительность:** Неправильное использование DML-команд, например, массовое обновление или удаление данных без индексов, может негативно сказаться на производительности базы данных.

## Заключение

DML ? это важный компонент языка SQL, который позволяет управлять данными в базе данных. Понимание и правильное использование команд DML, таких как `SELECT`, `INSERT`, `UPDATE` и `DELETE`, являются ключевыми для работы с данными в реляционных базах данных. Эти операции позволяют гибко и эффективно управлять информацией, обеспечивая полноценное взаимодействие с хранилищем данных на уровне приложения.

# 3. Что такое TCL? Какие операции в него входят?

**TCL (Transaction Control Language)** ? это подмножество SQL, предназначенное для управления транзакциями в базах данных. Команды TCL позволяют контролировать выполнение групп операций над данными, обеспечивая их целостность и согласованность. Основная задача TCL ? управление транзакциями, что важно для гарантии корректности выполнения операций в многопользовательской среде.

Транзакция ? это последовательность операций, которые выполняются как единое целое. Если одна из операций не может быть выполнена, все изменения отменяются, чтобы база данных вернулась в состояние, в котором она была до начала транзакции.

## Основные операции TCL

В TCL входят следующие команды:

1. **COMMIT** ? фиксация изменений, сделанных в рамках транзакции.
2. **ROLLBACK** ? отмена всех изменений, сделанных в рамках текущей транзакции.
3. **SAVEPOINT** ? создание точки сохранения внутри транзакции для частичного отката.
4. **SET TRANSACTION** ? настройка параметров транзакции, таких как уровень изоляции.

### 1. COMMIT

Команда **COMMIT** используется для фиксации всех изменений, сделанных в рамках текущей транзакции. После выполнения `COMMIT` все изменения становятся постоянными и видимыми другим пользователям.

#### Пример использования:

```sql
BEGIN;

UPDATE Employees SET Salary = Salary + 1000 WHERE EmployeeID = 1;
INSERT INTO Logs (Action, Timestamp) VALUES ('Salary Updated', NOW());

COMMIT;
```

### Объяснение:

- **BEGIN;** ? начало транзакции.
- Выполняются две операции: увеличение зарплаты и запись в лог.
- **COMMIT;** ? фиксация изменений, сделанных в транзакции. Теперь эти изменения будут видны всем пользователям базы данных.

### 2. ROLLBACK

Команда **ROLLBACK** используется для отмены изменений, сделанных в текущей транзакции. Она возвращает базу данных в состояние, которое было до начала транзакции.

#### Пример использования:

```sql
BEGIN;

UPDATE Employees SET Salary = Salary + 1000 WHERE EmployeeID = 1;
INSERT INTO Logs (Action, Timestamp) VALUES ('Salary Updated', NOW());

ROLLBACK;
```

### Объяснение:

- В данном примере изменения, сделанные в транзакции, будут отменены командой `ROLLBACK`. Это полезно в случае ошибок или при необходимости отменить операцию.

### 3. SAVEPOINT

Команда **SAVEPOINT** используется для создания точек сохранения внутри транзакции. Это позволяет откатиться только до определенного момента внутри транзакции, не отменяя всю транзакцию целиком.

#### Пример использования:

```sql
BEGIN;

SAVEPOINT sp1;

UPDATE Employees SET Salary = Salary + 1000 WHERE EmployeeID = 1;

SAVEPOINT sp2;

INSERT INTO Logs (Action, Timestamp) VALUES ('Salary Updated', NOW());

ROLLBACK TO sp1;

COMMIT;
```

### Объяснение:

- **SAVEPOINT sp1;** ? создается точка сохранения.
- **ROLLBACK TO sp1;** ? откат изменений до точки `sp1`, отменяя только те изменения, которые были выполнены после этой точки. Транзакция завершится фиксацией оставшихся изменений.

### 4. SET TRANSACTION

Команда **SET TRANSACTION** используется для настройки параметров транзакции, таких как уровень изоляции. Это позволяет управлять тем, как транзакция взаимодействует с другими транзакциями.

#### Пример использования:

```sql
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;

BEGIN;

UPDATE Employees SET Salary = Salary + 1000 WHERE EmployeeID = 1;

COMMIT;
```

### Объяснение:

- **SET TRANSACTION ISOLATION LEVEL READ COMMITTED;** ? задает уровень изоляции транзакции, чтобы она читала только те данные, которые уже зафиксированы другими транзакциями.

## Особенности TCL

1. **Управление целостностью данных:** TCL обеспечивает целостность данных при выполнении множества связанных операций.

2. **Контроль согласованности:** Транзакции помогают поддерживать согласованное состояние базы данных, даже в условиях сбоя или ошибки.

3. **Уровни изоляции:** С помощью TCL можно управлять изоляцией транзакций, чтобы контролировать взаимодействие параллельных транзакций и избежать проблем, таких как грязное чтение или фантомные записи.

4. **Многопользовательская среда:** TCL играет ключевую роль в многопользовательских системах, предотвращая конфликты и обеспечивая корректность выполнения операций.

## Заключение

**TCL** ? это важный инструмент для управления транзакциями в базах данных. Основные команды (`COMMIT`, `ROLLBACK`, `SAVEPOINT`, `SET TRANSACTION`) позволяют разработчикам контролировать выполнение групп операций и обеспечивать целостность данных. Использование TCL помогает создавать надежные и устойчивые к ошибкам приложения, работающие с базами данных.

# 4. Что такое DCL? Какие операции в него входят?

**DCL (Data Control Language)** ? это подмножество SQL, предназначенное для управления доступом к данным в базе данных, обеспечивая безопасность и контроль прав пользователей. Основная задача DCL ? предоставление и отзыв прав доступа к объектам базы данных, таким как таблицы, представления и процедуры, что помогает поддерживать безопасность данных и контролировать, кто и как может взаимодействовать с данными.

## Основные операции DCL

В DCL входят две ключевые команды:

1. **GRANT** ? предоставляет пользователям права доступа к объектам базы данных.
2. **REVOKE** ? отзывает ранее предоставленные права доступа.

### 1. GRANT

Команда **GRANT** используется для предоставления прав доступа пользователям или ролям на различные объекты базы данных, такие как таблицы, представления, процедуры и функции. С помощью этой команды администраторы могут управлять правами на чтение, запись, изменение и выполнение объектов базы данных.

#### Пример использования:

```sql
GRANT SELECT, INSERT ON Employees TO user1;
```

### Объяснение:

- **GRANT SELECT, INSERT** ? предоставляет права на выполнение операций `SELECT` и `INSERT`.
- **ON Employees** ? указывает, что эти права предоставляются на таблицу `Employees`.
- **TO user1** ? указывает, что права назначаются пользователю `user1`.

#### Другие примеры:

- **Предоставление права на выполнение процедуры:**

  ```sql
  GRANT EXECUTE ON PROCEDURE updateSalary TO hr_manager;
  ```

- **Предоставление всех прав на таблицу:**

  ```sql
  GRANT ALL PRIVILEGES ON Sales TO admin_user;
  ```

### 2. REVOKE

Команда **REVOKE** используется для отзыва прав доступа, которые ранее были предоставлены пользователям или ролям. Она позволяет ограничить доступ, если права больше не нужны или если необходимо усилить безопасность.

#### Пример использования:

```sql
REVOKE INSERT ON Employees FROM user1;
```

### Объяснение:

- **REVOKE INSERT** ? отзывает право на выполнение операции `INSERT`.
- **ON Employees** ? указывает, что право отзывается для таблицы `Employees`.
- **FROM user1** ? указывает, что право отзывается у пользователя `user1`.

#### Другие примеры:

- **Отзыв права на выполнение процедуры:**

  ```sql
  REVOKE EXECUTE ON PROCEDURE updateSalary FROM hr_manager;
  ```

- **Отзыв всех прав на таблицу:**

  ```sql
  REVOKE ALL PRIVILEGES ON Sales FROM admin_user;
  ```

## Особенности DCL

1. **Управление безопасностью:** DCL обеспечивает безопасность данных, позволяя контролировать, кто имеет доступ к различным объектам базы данных и каким образом этот доступ осуществляется.

2. **Гибкость в управлении правами:** Используя DCL, администраторы могут предоставлять права на уровне отдельных операций (чтение, запись, выполнение и т.д.) и для различных объектов базы данных.

3. **Уровни доступа:** DCL позволяет управлять доступом на разных уровнях ? от отдельных столбцов до целых баз данных, что дает гибкость в настройке безопасности.

4. **Управление пользователями и ролями:** Команды DCL работают не только с отдельными пользователями, но и с ролями, что упрощает управление правами в крупных системах.

## Заключение

**DCL** является важным инструментом для управления доступом к данным и объектам в базе данных. Основные команды (`GRANT` и `REVOKE`) позволяют администраторам настраивать права доступа, обеспечивая необходимый уровень безопасности. Это критически важно для защиты данных от несанкционированного доступа и обеспечения работы приложений в соответствии с политиками безопасности организации.

# 5. Нюансы работы с NULL в SQL. Как проверить поле на NULL?

**NULL** в SQL представляет собой отсутствие значения или неизвестное значение в базе данных. Это специальное значение, которое отличается от нуля, пустой строки или любого другого значения, и имеет ряд особенностей, которые необходимо учитывать при работе с данными.

## Особенности и нюансы работы с NULL

1. **NULL не является значением:** NULL означает отсутствие значения. Оно не является числом, строкой или датой, поэтому NULL нельзя напрямую сравнивать с другими значениями, включая другие NULL.

2. **Операции с NULL:** Любая арифметическая или логическая операция с NULL возвращает NULL. Например, `5 + NULL` вернет NULL, а выражение `NULL = NULL` вернет NULL, а не `TRUE` или `FALSE`.

3. **Сравнение с NULL:** Нельзя использовать обычные операторы сравнения (`=`, `!=`, `<`, `>`) для проверки на NULL. Для этого используются специальные операторы: `IS NULL` и `IS NOT NULL`.

4. **NULL в агрегационных функциях:** Агрегационные функции, такие как `SUM`, `AVG`, `MAX`, `MIN`, игнорируют значения NULL. Например, при вычислении среднего значения NULL не учитывается, но при этом функции, такие как `COUNT(*),` учитывают NULL.

5. **Условия в WHERE:** NULL в условиях WHERE требует специальных проверок, так как стандартные логические операторы не работают с NULL.

6. **Объединение строк с NULL:** При объединении строк (конкатенации) с NULL результатом будет NULL.

## Как проверить поле на NULL?

Для проверки значения поля на NULL используются операторы **`IS NULL`** и **`IS NOT NULL`**.

### Пример использования `IS NULL`

```sql
SELECT * FROM Employees WHERE BirthDate IS NULL;
```

### Объяснение:

- Этот запрос выбирает все записи из таблицы `Employees`, у которых поле `BirthDate` имеет значение NULL.

### Пример использования `IS NOT NULL`

```sql
SELECT * FROM Employees WHERE BirthDate IS NOT NULL;
```

### Объяснение:

- Этот запрос выбирает все записи, у которых поле `BirthDate` не равно NULL (имеет значение).

## Дополнительные аспекты работы с NULL

### 1. Использование функции COALESCE

Функция **`COALESCE`** позволяет заменять значения NULL на указанные значения. Она возвращает первое ненулевое значение из списка аргументов.

#### Пример использования COALESCE:

```sql
SELECT FirstName, COALESCE(BirthDate, '1900-01-01') AS BirthDate
FROM Employees;
```

### Объяснение:

- Если `BirthDate` равно NULL, то вместо NULL будет возвращена дата `'1900-01-01'`.

### 2. Использование функции IFNULL (или ISNULL)

Функции **`IFNULL`** (MySQL) и **`ISNULL`** (SQL Server) заменяют NULL на указанное значение.

#### Пример использования IFNULL:

```sql
SELECT FirstName, IFNULL(LastName, 'Unknown') AS LastName
FROM Employees;
```

### Объяснение:

- Если `LastName` равно NULL, вместо NULL будет возвращено значение `'Unknown'`.

### 3. Особенности при сортировке

При сортировке значений с NULL, NULL обычно считается наименьшим значением, поэтому строки с NULL часто оказываются в начале или в конце списка в зависимости от направления сортировки.

#### Пример сортировки:

```sql
SELECT * FROM Employees ORDER BY BirthDate ASC;
```

### Объяснение:

- Записи с `NULL` в `BirthDate` будут первыми при сортировке по возрастанию.

### 4. Сравнение NULL с помощью CASE

Использование `CASE` позволяет обрабатывать NULL значения внутри логики запросов.

#### Пример использования CASE:

```sql
SELECT FirstName,
       CASE
           WHEN BirthDate IS NULL THEN 'Дата не указана'
           ELSE 'Дата указана'
       END AS BirthDateStatus
FROM Employees;
```

### Объяснение:

- Возвращает `'Дата не указана'`, если значение `BirthDate` равно NULL, иначе ? `'Дата указана'`.

## Заключение

Работа с NULL в SQL требует специального подхода, поскольку это значение представляет отсутствие данных, а не просто пустое значение. Для корректной проверки и работы с NULL важно использовать операторы `IS NULL` и `IS NOT NULL`, а также функции обработки NULL, такие как `COALESCE`, `IFNULL`, и другие. Понимание особенностей NULL помогает избежать логических ошибок и обеспечивает корректное поведение запросов к базе данных.

# 6. Виды Join'ов

**JOIN** ? это ключевая операция в SQL, которая используется для объединения строк из двух или более таблиц на основе связанных между ними столбцов. Существует несколько видов `JOIN`, каждый из которых имеет свою специфику и используется в зависимости от того, какие данные необходимо получить.

## Основные виды JOIN

1. **INNER JOIN**
2. **LEFT JOIN (LEFT OUTER JOIN)**
3. **RIGHT JOIN (RIGHT OUTER JOIN)**
4. **FULL JOIN (FULL OUTER JOIN)**
5. **CROSS JOIN**
6. **SELF JOIN**
7. **NATURAL JOIN**

### 1. INNER JOIN

**INNER JOIN** возвращает строки, которые имеют совпадающие значения в обеих таблицах. Это самый распространенный вид соединения, который используется для выборки только тех записей, которые соответствуют критерию соединения.

![alt text](data/image/image1.png)

#### Пример использования INNER JOIN:

```sql
SELECT Employees.EmployeeID, Employees.Name, Departments.DepartmentName
FROM Employees
INNER JOIN Departments ON Employees.DepartmentID = Departments.DepartmentID;
```

### Объяснение:

- Соединяет таблицы `Employees` и `Departments`, возвращая только те строки, где `DepartmentID` совпадает в обеих таблицах.

### 2. LEFT JOIN (LEFT OUTER JOIN)

**LEFT JOIN** возвращает все строки из левой таблицы и соответствующие строки из правой таблицы. Если совпадений нет, то вместо значений из правой таблицы будут NULL.

![alt text](data/image/image2.png)

#### Пример использования LEFT JOIN:

```sql
SELECT Employees.EmployeeID, Employees.Name, Departments.DepartmentName
FROM Employees
LEFT JOIN Departments ON Employees.DepartmentID = Departments.DepartmentID;
```

### Объяснение:

- Возвращает все строки из таблицы `Employees` и соответствующие строки из `Departments`. Если у сотрудника нет департамента, то вместо `DepartmentName` будет NULL.

### 3. RIGHT JOIN (RIGHT OUTER JOIN)

**RIGHT JOIN** работает аналогично LEFT JOIN, но возвращает все строки из правой таблицы и соответствующие строки из левой таблицы. Если совпадений нет, значения из левой таблицы будут NULL.

![alt text](data/image/image3.png)

#### Пример использования RIGHT JOIN:

```sql
SELECT Employees.EmployeeID, Employees.Name, Departments.DepartmentName
FROM Employees
RIGHT JOIN Departments ON Employees.DepartmentID = Departments.DepartmentID;
```

### Объяснение:

- Возвращает все строки из `Departments` и соответствующие строки из `Employees`. Если департамент не имеет сотрудников, то значения из `Employees` будут NULL.

### 4. FULL JOIN (FULL OUTER JOIN)

**FULL JOIN** возвращает все строки, когда есть совпадения либо в левой, либо в правой таблице. Если совпадений нет, строки будут дополнены NULL с противоположной стороны.

![alt text](data/image/image4.png)

#### Пример использования FULL JOIN:

```sql
SELECT Employees.EmployeeID, Employees.Name, Departments.DepartmentName
FROM Employees
FULL JOIN Departments ON Employees.DepartmentID = Departments.DepartmentID;
```

### Объяснение:

- Возвращает все строки как из `Employees`, так и из `Departments`. Если строка не имеет совпадения с другой таблицей, то соответствующие значения будут NULL.

### 5. CROSS JOIN

**CROSS JOIN** возвращает декартово произведение двух таблиц. Каждая строка из первой таблицы соединяется с каждой строкой из второй таблицы.

![alt text](data/image/image5.png)

#### Пример использования CROSS JOIN:

```sql
SELECT Employees.Name, Departments.DepartmentName
FROM Employees
CROSS JOIN Departments;
```

### Объяснение:

- Возвращает все возможные комбинации строк из `Employees` и `Departments`.

### 6. SELF JOIN

**SELF JOIN** ? это соединение таблицы с самой собой. Используется, когда нужно связать строки одной таблицы друг с другом.

#### Пример использования SELF JOIN:

```sql
SELECT A.EmployeeID, A.Name, B.Name AS ManagerName
FROM Employees A
LEFT JOIN Employees B ON A.ManagerID = B.EmployeeID;
```

### Объяснение:

- Таблица `Employees` соединяется сама с собой для получения имен менеджеров сотрудников.

### 7. NATURAL JOIN

**NATURAL JOIN** автоматически соединяет таблицы на основе всех столбцов с одинаковыми именами и типами данных. Это упрощенная форма JOIN, но не всегда рекомендуется из-за возможных неоднозначностей.

#### Пример использования NATURAL JOIN:

```sql
SELECT *
FROM Employees
NATURAL JOIN Departments;
```

### Объяснение:

- Соединяет `Employees` и `Departments` по всем одинаковым столбцам. Рекомендуется использовать с осторожностью, так как результат может быть неожиданным, если таблицы имеют много одинаковых столбцов.

## Заключение

Различные виды JOIN позволяют гибко управлять выборкой данных из нескольких таблиц, объединяя их на основе условий. Каждый тип JOIN имеет свои особенности и используется в зависимости от задачи, будь то выборка только совпадающих строк (INNER JOIN), получение всех строк из одной из таблиц (LEFT или RIGHT JOIN), или объединение всех строк независимо от совпадений (FULL JOIN). Понимание этих видов соединений позволяет эффективно работать с реляционными базами данных и извлекать необходимые данные с учетом их взаимосвязей.

# 7. Что лучше использовать: JOIN или подзапросы? Почему?

Использование `JOIN` или подзапросов в SQL зависит от конкретного сценария и требований к выполнению запросов. Оба подхода имеют свои преимущества и недостатки, и их выбор влияет на производительность, читаемость и поддерживаемость SQL-кода.

## JOIN vs Подзапросы: Основные отличия

- **JOIN** используется для соединения нескольких таблиц в одном запросе на основе заданных условий.
- **Подзапросы** (subqueries) ? это вложенные запросы, которые используются внутри основного запроса и могут возвращать одно значение, строку или целую таблицу.

## Преимущества и недостатки JOIN

### Преимущества JOIN:

1. **Высокая производительность:** `JOIN` чаще всего работает быстрее, так как оптимизаторы баз данных лучше справляются с обработкой соединений таблиц, особенно если заданы соответствующие индексы.

2. **Читаемость и логичность:** `JOIN` часто делает запрос более читаемым, так как сразу видно, как связаны таблицы и по каким условиям выполняется соединение.

3. **Меньшая нагрузка на память:** `JOIN` обычно использует меньше оперативной памяти, поскольку работает на уровне строк и выполняет операции непосредственно с соединенными данными.

4. **Гибкость:** `JOIN` позволяет легко комбинировать и фильтровать данные с использованием различных типов соединений (`INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN`, и т.д.).

### Недостатки JOIN:

1. **Сложность при работе с многослойными условиями:** Когда необходимо фильтровать данные на нескольких уровнях, запросы с JOIN могут становиться громоздкими и сложными для понимания.

2. **Потенциальные проблемы с дубликатами:** При неправильных условиях соединения возможны неожиданные дубликаты строк.

## Преимущества и недостатки подзапросов

### Преимущества подзапросов:

1. **Удобство для фильтрации:** Подзапросы могут быть удобны, когда нужно использовать результаты одного запроса в другом, например, для фильтрации данных (`WHERE`, `IN`, `EXISTS`).

2. **Логическая группировка:** Подзапросы могут логически сгруппировать сложные фильтрации, делая основной запрос чище и более управляемым.

3. **Упрощение сложных вычислений:** Вложенные подзапросы позволяют разбивать сложные операции на более мелкие шаги.

4. **Возможность выполнения независимых вычислений:** Подзапросы могут выполнять вычисления, которые невозможно реализовать через прямое соединение с помощью JOIN.

### Недостатки подзапросов:

1. **Медленная производительность:** Подзапросы могут быть менее эффективными, особенно если они вложены глубоко, так как оптимизатору базы данных труднее их оптимизировать.

2. **Высокая нагрузка на память:** Подзапросы могут загружать результаты во временные таблицы, увеличивая потребление оперативной памяти и замедляя выполнение.

3. **Ограниченная гибкость:** Подзапросы могут усложнить структуру кода, и их использование для сложных фильтраций и соединений делает запрос менее гибким по сравнению с JOIN.

## Когда использовать JOIN?

1. **Объединение данных из нескольких таблиц:** JOIN лучше подходит, когда необходимо объединить данные из разных таблиц с целью их дальнейшей фильтрации, сортировки или агрегации.

2. **Высокая производительность:** Если важна скорость выполнения запроса и низкое использование ресурсов, JOIN обычно предпочтительнее.

3. **Ясность связей:** Если необходимо показать четкие связи между данными таблиц, JOIN делает запросы более понятными и логически структурированными.

## Когда использовать подзапросы?

1. **Фильтрация и вычисления:** Подзапросы полезны для фильтрации на основании результатов других запросов, особенно когда они используются в конструкции `WHERE`, `IN`, или `EXISTS`.

2. **Независимые вычисления:** Когда нужно выполнить независимое от основного запроса вычисление или агрегирование данных.

3. **Упрощение сложных запросов:** Подзапросы могут помочь разбить сложные вычисления на логически отдельные части, особенно при работе с агрегированием или при необходимости применения фильтраций на разных уровнях.

## Пример сравнения JOIN и подзапроса

### Пример с использованием JOIN:

```sql
SELECT Employees.Name, Departments.DepartmentName
FROM Employees
JOIN Departments ON Employees.DepartmentID = Departments.DepartmentID;
```

### Пример с использованием подзапроса:

```sql
SELECT Name 
FROM Employees 
WHERE DepartmentID IN (
    SELECT DepartmentID 
    FROM Departments 
    WHERE DepartmentName = 'IT'
);
```

### Объяснение:

- В первом случае, `JOIN` напрямую соединяет две таблицы на основе общего столбца и возвращает связанные строки.
- Во втором случае, подзапрос сначала находит нужные `DepartmentID`, а затем используется для фильтрации данных из основной таблицы.

## Заключение

- **JOIN** предпочтительнее, когда необходимо быстро и эффективно объединить данные из нескольких таблиц, особенно если заданы индексы.
- **Подзапросы** более полезны, когда нужно выполнять независимые фильтрации или вычисления.
- В большинстве случаев **JOIN** будет работать быстрее и предпочтительнее с точки зрения производительности, но подзапросы могут упростить логику запросов и быть более интуитивными для сложных вычислений. 

Оптимальный подход ? тестировать оба метода в конкретных сценариях и выбирать тот, который лучше подходит с учетом производительности и читаемости кода.

# 8. Что делает UNION?

**UNION** ? это оператор в SQL, который используется для объединения результатов двух или более `SELECT` запросов в одну результирующую таблицу. Он позволяет комбинировать строки из разных запросов, при этом удаляя дубликаты (по умолчанию), что делает его полезным для работы с данными, полученными из разных источников или таблиц.

## Как работает UNION?

- **Синтаксис**: 
  ```sql
  SELECT column1, column2, ...
  FROM table1
  UNION
  SELECT column1, column2, ...
  FROM table2;
  ```

- **Общие условия**:
  - Количество и порядок столбцов в каждом запросе должны совпадать.
  - Типы данных соответствующих столбцов должны быть совместимыми.

## Основные виды UNION

1. **UNION (без указания DISTINCT)**:
   - По умолчанию удаляет дубликаты строк из объединенных результатов.
   - Полезен, когда важны уникальные записи из разных запросов.

2. **UNION ALL**:
   - Объединяет результаты запросов, сохраняя все строки, включая дубликаты.
   - Быстрее, чем `UNION`, так как не выполняет проверку на уникальность.

## Пример использования UNION

### Пример с UNION:

```sql
SELECT Name, Country FROM Customers_US
UNION
SELECT Name, Country FROM Customers_Europe;
```

### Ожидаемый вывод:
```
| Name          | Country   |
|---------------|-----------|
| John Doe      | USA       |
| Jane Smith    | UK        |
| Alice Johnson | USA       |
```

- В данном примере `UNION` объединяет результаты запросов из таблиц `Customers_US` и `Customers_Europe`, удаляя дубликаты.

### Пример с UNION ALL:

```sql
SELECT Name, Country FROM Customers_US
UNION ALL
SELECT Name, Country FROM Customers_Europe;
```

### Ожидаемый вывод:
```
| Name          | Country   |
|---------------|-----------|
| John Doe      | USA       |
| Jane Smith    | UK        |
| John Doe      | USA       |  -- Дубликат сохранен
| Alice Johnson | USA       |
```

- В этом случае `UNION ALL` объединяет все строки, включая дубликаты.

## Когда использовать UNION и UNION ALL?

- **UNION** полезен, когда нужно получить уникальные строки без повторений, но это требует дополнительной проверки на уникальность и может замедлить выполнение запроса.
- **UNION ALL** предпочтителен, когда важна производительность и нет необходимости удалять дубликаты. Он быстрее за счет отсутствия проверки на уникальность.

## Примеры практического использования

1. **Объединение данных из нескольких источников**: Когда необходимо комбинировать данные из разных таблиц или представлений с одинаковыми структурами.
   
2. **Слияние результатов разных фильтраций**: Для получения общих результатов, например, объединение данных по разным критериям поиска.

3. **Работа с распределенными данными**: В сценариях, где данные хранятся в разных базах данных или таблицах, и необходимо собрать все данные в одном месте.

## Заключение

Оператор `UNION` ? это мощный инструмент для объединения данных из нескольких источников в SQL. Он позволяет гибко комбинировать результаты запросов, устраняя дубликаты (или сохраняя их с помощью `UNION ALL`), что делает его полезным в широком спектре задач, от простого слияния данных до сложной агрегации результатов из разных таблиц.

# 9. Чем WHERE отличается от HAVING?

Операторы `WHERE` и `HAVING` в SQL используются для фильтрации данных в запросах, но они выполняют фильтрацию на разных этапах выполнения запроса и предназначены для разных целей. Основное различие между ними заключается в том, что `WHERE` фильтрует строки **до** группировки данных, а `HAVING` ? **после** группировки.

## Основные отличия между WHERE и HAVING

### 1. WHERE

- **Фильтрация данных перед группировкой:** `WHERE` используется для фильтрации строк на этапе предварительной обработки данных, то есть **до** выполнения агрегатных функций и группировки.
- **Не работает с агрегатными функциями:** Условие `WHERE` не может содержать агрегатные функции (`SUM`, `AVG`, `COUNT`, `MAX`, `MIN` и т.д.), поскольку оно применяется к данным до их агрегации.
- **Применяется к строкам таблицы:** Используется для фильтрации отдельных строк данных таблицы на этапе выборки.

**Пример использования WHERE:**

```sql
SELECT Name, Age 
FROM Employees
WHERE Age > 30;
```

- В этом запросе `WHERE` фильтрует строки таблицы `Employees`, отбирая только те, у которых `Age` больше 30.

### 2. HAVING

- **Фильтрация после группировки:** `HAVING` используется для фильтрации результатов **после** выполнения группировки данных с помощью `GROUP BY`.
- **Работает с агрегатными функциями:** `HAVING` поддерживает использование агрегатных функций, что позволяет применять фильтры к результатам группировки.
- **Применяется к сгруппированным данным:** Фильтрует группы строк после выполнения агрегации.

**Пример использования HAVING:**

```sql
SELECT Department, COUNT(*)
FROM Employees
GROUP BY Department
HAVING COUNT(*) > 5;
```

- В этом запросе сначала выполняется группировка сотрудников по департаментам, а затем `HAVING` фильтрует только те департаменты, в которых количество сотрудников больше 5.

## Сравнительный пример WHERE и HAVING

Рассмотрим ситуацию, когда необходимо отобрать департаменты с более чем 5 сотрудниками старше 30 лет.

### Пример с WHERE и HAVING вместе:

```sql
SELECT Department, COUNT(*)
FROM Employees
WHERE Age > 30
GROUP BY Department
HAVING COUNT(*) > 5;
```

### Объяснение:

1. **WHERE Age > 30**: Сначала выполняется фильтрация строк ? отбираются сотрудники старше 30 лет.
2. **GROUP BY Department**: Затем данные группируются по департаментам.
3. **HAVING COUNT(*) > 5**: Наконец, `HAVING` фильтрует департаменты, в которых после группировки осталось более 5 сотрудников.

## Важные различия и особенности

1. **Последовательность применения:**
   - `WHERE` ? используется до `GROUP BY`, фильтрует исходные данные.
   - `HAVING` ? используется после `GROUP BY`, фильтрует агрегированные результаты.

2. **Использование с агрегатными функциями:**
   - `WHERE` не поддерживает агрегатные функции.
   - `HAVING` поддерживает, так как применяется к уже агрегированным данным.

3. **Производительность:**
   - `WHERE` обычно быстрее, так как работает с необработанными данными.
   - `HAVING` применяется после группировки и агрегации, что делает его менее производительным на больших объемах данных.

## Когда использовать WHERE и HAVING?

- **Используйте `WHERE`**, когда вам нужно отфильтровать строки на начальном этапе выборки, до выполнения агрегации или группировки.
- **Используйте `HAVING`**, когда необходимо фильтровать данные на основе агрегированных значений или групп.

## Заключение

Операторы `WHERE` и `HAVING` являются важными инструментами для фильтрации данных в SQL, но их различия в порядке применения и поддержке агрегатных функций делают их подходящими для различных задач. `WHERE` используется для фильтрации исходных строк данных, а `HAVING` ? для фильтрации уже сгруппированных и агрегированных данных, что делает их дополняющими друг друга инструментами для сложных SQL-запросов.
