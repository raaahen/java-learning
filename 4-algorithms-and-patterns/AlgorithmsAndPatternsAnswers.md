# 1. Что такое «шаблон проектирования»?

**Шаблон проектирования** (Design Pattern) — это повторяемое решение часто встречающейся проблемы в проектировании программного обеспечения. Шаблоны проектирования не являются готовым кодом, а представляют собой наборы рекомендаций и структур, которые помогают разработчикам решать типичные задачи, такие как создание объектов, организация взаимодействий между объектами и обеспечение структурирования кода.

## Основные типы шаблонов проектирования

1. **Порождающие (Creational Patterns)** — управляют процессом создания объектов, облегчая создание новых экземпляров классов и уменьшая связанность кода. Примеры: Singleton, Factory Method, Builder, Prototype.

2. **Структурные (Structural Patterns)** — упрощают реализацию отношений между объектами, обеспечивая эффективную компоновку классов и объектов. Примеры: Adapter, Composite, Decorator, Proxy, Facade.

3. **Поведенческие (Behavioral Patterns)** — определяют способы взаимодействия объектов, распределяя обязанности и обеспечивая гибкое поведение системы. Примеры: Observer, Strategy, Command, State, Mediator.

## Преимущества использования шаблонов проектирования

- **Повышение читаемости кода:** Шаблоны являются общепринятыми решениями, их использование делает код понятным и предсказуемым для опытных разработчиков.
- **Ускорение разработки:** Позволяют быстро найти решение для часто встречающихся проблем, не изобретая «велосипед».
- **Повышение гибкости и расширяемости:** Способствуют созданию кода, который легко адаптируется к изменениям требований.

## Заключение

Шаблоны проектирования являются важным инструментом в арсенале разработчика, помогая создавать структурированный, понятный и легко поддерживаемый код. Они обеспечивают проверенные решения для архитектурных задач и способствуют лучшим практикам программирования.

# 2. Назовите основные характеристики шаблонов

Шаблоны проектирования обладают несколькими ключевыми характеристиками, которые помогают разработчикам эффективно использовать их для решения типичных задач в разработке программного обеспечения.

## Основные характеристики шаблонов

1. **Имя (Name)**  
   Каждому шаблону проектирования присвоено уникальное имя, которое служит для облегчения обсуждения и идентификации. Это имя становится частью профессионального жаргона и помогает разработчикам быстрее понимать обсуждаемые решения. Например: Singleton, Observer, Factory Method.

2. **Задача (Problem)**  
   Шаблон проектирования всегда ориентирован на решение конкретной проблемы. Это описание ситуации, в которой можно применить данный шаблон, и то, какие проблемы возникают без его использования. Важна четкая формулировка контекста, в котором шаблон эффективен.

3. **Решение (Solution)**  
   Описание структуры шаблона, его участников и их взаимодействий. Это общее руководство к реализации, не зависящее от конкретных языков программирования. Решение не представляет собой готовый код, а описывает, как можно организовать классы и объекты для достижения цели.

4. **Последствия (Consequences)**  
   Описание преимуществ и недостатков использования шаблона. Каждое решение имеет свои плюсы и минусы, которые нужно учитывать при выборе подходящего шаблона для решения задачи. Важно учитывать производительность, гибкость и сложность реализации.

5. **Участники (Participants)**  
   Шаблон описывает роли объектов и классов, участвующих в его реализации. Например, в шаблоне "Наблюдатель" (Observer) есть два участника: "Наблюдатель" и "Субъект".

6. **Применимость (Applicability)**  
   Описание контекста, в котором шаблон лучше всего подходит для использования. Это помогает разработчикам определить, в каких ситуациях шаблон решает проблемы наилучшим образом и где его следует избегать.

7. **Структура (Structure)**  
   Диаграмма классов или объектов, которая иллюстрирует связи и взаимодействия между компонентами шаблона. Это визуальное представление помогает лучше понять, как функционирует шаблон.

## Заключение

Эти характеристики позволяют точно описать шаблоны проектирования, сделать их легко узнаваемыми и применимыми в реальных проектах. Понимание этих аспектов помогает разработчикам эффективно выбирать и использовать шаблоны для решения конкретных задач.

# 3. Назовите три основные группы паттернов

Шаблоны проектирования (паттерны) делятся на три основные группы, каждая из которых ориентирована на решение конкретного типа проблем в разработке программного обеспечения. Эти группы известны как **порождающие**, **структурные** и **поведенческие** паттерны.

## 1. Порождающие паттерны (Creational Patterns)

Порождающие паттерны сосредоточены на управлении процессом создания объектов. Они помогают абстрагировать процесс инстанцирования и сделать его более гибким, контролируя создание объектов таким образом, чтобы они соответствовали требованиям системы.

### Примеры:
- **Singleton** — гарантирует, что у класса будет только один экземпляр, и предоставляет глобальную точку доступа к нему.
- **Factory Method** — определяет интерфейс для создания объектов, но позволяет подклассам изменять тип создаваемого объекта.
- **Abstract Factory** — предоставляет интерфейс для создания семейств взаимосвязанных объектов без указания их конкретных классов.
- **Builder** — разделяет создание сложного объекта от его представления, чтобы один и тот же процесс мог создавать разные представления.
- **Prototype** — создает новые объекты путем копирования существующих объектов (прототипов).

## 2. Структурные паттерны (Structural Patterns)

Структурные паттерны помогают организовать классы и объекты в более крупные структуры, обеспечивая гибкость и эффективность системы. Эти паттерны фокусируются на компоновке объектов и классов, предоставляя возможность более удобно интегрировать различные компоненты системы.

### Примеры:
- **Adapter** — позволяет объектам с несовместимыми интерфейсами работать вместе, выступая в роли посредника.
- **Bridge** — разделяет абстракцию и реализацию так, чтобы они могли изменяться независимо.
- **Composite** — позволяет группировать объекты в древовидные структуры для представления иерархий типа "часть-целое".
- **Decorator** — динамически добавляет новые обязанности объекту, не изменяя его класс.
- **Facade** — предоставляет упрощенный интерфейс к сложной системе или набору интерфейсов.
- **Proxy** — создает заместителя для другого объекта, чтобы контролировать доступ к нему.

## 3. Поведенческие паттерны (Behavioral Patterns)

Поведенческие паттерны описывают способы взаимодействия между объектами и управления потоком данных в системе. Эти паттерны сосредоточены на том, как объекты взаимодействуют друг с другом, передают информацию и контролируют выполнение действий.

### Примеры:
- **Observer** — определяет зависимость типа "один ко многим", чтобы при изменении состояния одного объекта автоматически уведомлялись и обновлялись все зависимые объекты.
- **Strategy** — определяет семейство алгоритмов и делает их взаимозаменяемыми, позволяя менять алгоритм независимо от клиентов, которые его используют.
- **Command** — инкапсулирует запрос как объект, позволяя параметризовать клиентов с запросами, очередями или логами запросов.
- **State** — позволяет объекту изменять поведение при изменении его внутреннего состояния.
- **Chain of Responsibility** — передает запрос по цепочке обработчиков, где каждый обработчик решает, обработать запрос или передать его дальше.

## Заключение

Эти три группы паттернов помогают решать различные задачи на этапе проектирования: от управления созданием объектов (порождающие) до организации структуры (структурные) и взаимодействия объектов (поведенческие).

# 4. Расскажите про паттерн Одиночка (Singleton)

**Паттерн Singleton (Одиночка)** — это порождающий паттерн проектирования, который гарантирует, что у класса будет только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру. Основная цель паттерна — предотвратить создание более одного объекта класса, контролируя процесс инстанцирования.

## Основные характеристики Singleton

1. **Один экземпляр класса:** Паттерн гарантирует, что за всё время работы программы будет создан только один экземпляр данного класса.
2. **Глобальная точка доступа:** Этот экземпляр доступен в любой части программы через статический метод, обычно называемый `getInstance()`.
3. **Ленивая инициализация (опционально):** Объект может быть создан при первом обращении к нему, что позволяет избежать ненужного создания объекта до его реального использования.

## Пример реализации Singleton

### Реализация с ленивой инициализацией

```java
public class Singleton {
    // Приватное статическое поле, содержащее единственный экземпляр
    private static Singleton instance;

    // Приватный конструктор, чтобы предотвратить создание объектов извне
    private Singleton() {}

    // Публичный метод для получения единственного экземпляра класса
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton(); // Ленивая инициализация
        }
        return instance;
    }

    // Пример метода класса
    public void showMessage() {
        System.out.println("Hello, Singleton!");
    }
}
```

### Использование Singleton:

```java
public class Main {
    public static void main(String[] args) {
        Singleton singleton = Singleton.getInstance();
        singleton.showMessage();
    }
}
```

### Ожидаемый вывод:

```
Hello, Singleton!
```

## Потокобезопасная реализация Singleton

В многопоточных средах могут возникать проблемы с конкурентным доступом к методу `getInstance()`. Чтобы избежать этого, можно использовать синхронизацию или другие механизмы контроля доступа.

### Потокобезопасная реализация:

```java
public class ThreadSafeSingleton {
    private static ThreadSafeSingleton instance;

    private ThreadSafeSingleton() {}

    public static synchronized ThreadSafeSingleton getInstance() {
        if (instance == null) {
            instance = new ThreadSafeSingleton();
        }
        return instance;
    }
}
```

### Реализация с двойной проверкой блокировки (Double-checked locking):

```java
public class DoubleCheckedLockingSingleton {
    private static volatile DoubleCheckedLockingSingleton instance;

    private DoubleCheckedLockingSingleton() {}

    public static DoubleCheckedLockingSingleton getInstance() {
        if (instance == null) {
            synchronized (DoubleCheckedLockingSingleton.class) {
                if (instance == null) {
                    instance = new DoubleCheckedLockingSingleton();
                }
            }
        }
        return instance;
    }
}
```

### Примечания:
- **volatile** гарантирует, что изменения в переменной будут видны всем потокам.
- **Синхронизация** необходима для корректной работы в многопоточной среде.

## Преимущества Singleton

- **Контроль доступа:** Гарантия наличия единственного экземпляра класса.
- **Экономия ресурсов:** Если объект тяжёлый, его создание откладывается до первого вызова.
- **Глобальная доступность:** Лёгкий доступ к объекту в любом месте программы.

## Недостатки Singleton

- **Сложности с тестированием:** Трудно тестировать классы, зависящие от Singleton, так как его трудно заменять мок-объектами.
- **Проблемы с многопоточностью:** В незащищённых реализациях могут возникнуть гонки потоков при одновременном создании объекта.
- **Превращение в глобальную переменную:** Singleton может злоупотребляться для создания глобальных объектов, что нарушает инкапсуляцию.

## Заключение

Singleton является эффективным решением для создания единственного экземпляра объекта, но в многопоточной среде следует учитывать вопросы потокобезопасности.

# 5. Расскажите про паттерн Строитель (Builder)

**Строитель (Builder)** — это порождающий паттерн проектирования, который используется для пошагового конструирования сложных объектов. Он позволяет создавать объект, не заставляя клиентский код заботиться о деталях его создания, и предоставляет гибкость в сборке объекта за счет разделения процесса на этапы.

## Основные характеристики паттерна Строитель

1. **Пошаговая сборка объектов**: Процесс создания объекта разбит на этапы, и каждый этап может вызываться отдельно.
2. **Разделение конструкции и представления**: Строитель отделяет логику построения объекта от его конечного представления.
3. **Гибкость**: Позволяет создавать разные представления объекта, используя один и тот же процесс строительства.
4. **Необязательные параметры**: Удобно, если объект содержит множество опциональных параметров.

## Пример реализации паттерна Builder в Java

Рассмотрим класс `Person`, у которого много полей. Для создания объекта с определенными комбинациями полей можно использовать паттерн Строитель.

```java
public class Person {
    private final String firstName;
    private final String lastName;
    private final int age;
    private final String address;

    // Приватный конструктор
    private Person(Builder builder) {
        this.firstName = builder.firstName;
        this.lastName = builder.lastName;
        this.age = builder.age;
        this.address = builder.address;
    }

    // Статический класс Builder
    public static class Builder {
        private String firstName;
        private String lastName;
        private int age;
        private String address;

        public Builder setFirstName(String firstName) {
            this.firstName = firstName;
            return this;
        }

        public Builder setLastName(String lastName) {
            this.lastName = lastName;
            return this;
        }

        public Builder setAge(int age) {
            this.age = age;
            return this;
        }

        public Builder setAddress(String address) {
            this.address = address;
            return this;
        }

        // Метод для создания объекта Person
        public Person build() {
            return new Person(this);
        }
    }

    @Override
    public String toString() {
        return "Person{" +
                "firstName='" + firstName + '\'' +
                ", lastName='" + lastName + '\'' +
                ", age=" + age +
                ", address='" + address + '\'' +
                '}';
    }
}
```

### Пример использования:

```java
public class Main {
    public static void main(String[] args) {
        Person person = new Person.Builder()
                .setFirstName("John")
                .setLastName("Doe")
                .setAge(30)
                .setAddress("123 Main St")
                .build();

        System.out.println(person);
    }
}
```

### Ожидаемый вывод:

```
Person{firstName='John', lastName='Doe', age=30, address='123 Main St'}
```

## Особенности паттерна Builder

1. **Читаемость**: Код становится более читаемым, когда нужно задать несколько параметров. Например, мы можем задать только нужные параметры, не указывая все сразу.
2. **Гибкость**: Строитель может применяться для создания разных конфигураций объекта без необходимости создавать множество конструкторов.
3. **Неизменяемость**: Объект может быть неизменяемым, поскольку его поля задаются только при создании с помощью Строителя, а сам объект становится неизменяемым после создания.

## Когда использовать паттерн Строитель

- Когда объект содержит множество опциональных параметров.
- Когда необходимо обеспечить пошаговую сборку объекта.
- Когда нужно избежать большого числа перегруженных конструкторов.

## Заключение

Паттерн Строитель удобен при создании сложных объектов с множеством параметров, обеспечивая читабельный и гибкий подход к их созданию.
