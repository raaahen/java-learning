# 1. Что такое «шаблон проектирования»?

**Шаблон проектирования** (Design Pattern) — это повторяемое решение часто встречающейся проблемы в проектировании программного обеспечения. Шаблоны проектирования не являются готовым кодом, а представляют собой наборы рекомендаций и структур, которые помогают разработчикам решать типичные задачи, такие как создание объектов, организация взаимодействий между объектами и обеспечение структурирования кода.

## Основные типы шаблонов проектирования

1. **Порождающие (Creational Patterns)** — управляют процессом создания объектов, облегчая создание новых экземпляров классов и уменьшая связанность кода. Примеры: Singleton, Factory Method, Builder, Prototype.

2. **Структурные (Structural Patterns)** — упрощают реализацию отношений между объектами, обеспечивая эффективную компоновку классов и объектов. Примеры: Adapter, Composite, Decorator, Proxy, Facade.

3. **Поведенческие (Behavioral Patterns)** — определяют способы взаимодействия объектов, распределяя обязанности и обеспечивая гибкое поведение системы. Примеры: Observer, Strategy, Command, State, Mediator.

## Преимущества использования шаблонов проектирования

- **Повышение читаемости кода:** Шаблоны являются общепринятыми решениями, их использование делает код понятным и предсказуемым для опытных разработчиков.
- **Ускорение разработки:** Позволяют быстро найти решение для часто встречающихся проблем, не изобретая «велосипед».
- **Повышение гибкости и расширяемости:** Способствуют созданию кода, который легко адаптируется к изменениям требований.

## Заключение

Шаблоны проектирования являются важным инструментом в арсенале разработчика, помогая создавать структурированный, понятный и легко поддерживаемый код. Они обеспечивают проверенные решения для архитектурных задач и способствуют лучшим практикам программирования.

# 2. Назовите основные характеристики шаблонов

Шаблоны проектирования обладают несколькими ключевыми характеристиками, которые помогают разработчикам эффективно использовать их для решения типичных задач в разработке программного обеспечения.

## Основные характеристики шаблонов

1. **Имя (Name)**  
   Каждому шаблону проектирования присвоено уникальное имя, которое служит для облегчения обсуждения и идентификации. Это имя становится частью профессионального жаргона и помогает разработчикам быстрее понимать обсуждаемые решения. Например: Singleton, Observer, Factory Method.

2. **Задача (Problem)**  
   Шаблон проектирования всегда ориентирован на решение конкретной проблемы. Это описание ситуации, в которой можно применить данный шаблон, и то, какие проблемы возникают без его использования. Важна четкая формулировка контекста, в котором шаблон эффективен.

3. **Решение (Solution)**  
   Описание структуры шаблона, его участников и их взаимодействий. Это общее руководство к реализации, не зависящее от конкретных языков программирования. Решение не представляет собой готовый код, а описывает, как можно организовать классы и объекты для достижения цели.

4. **Последствия (Consequences)**  
   Описание преимуществ и недостатков использования шаблона. Каждое решение имеет свои плюсы и минусы, которые нужно учитывать при выборе подходящего шаблона для решения задачи. Важно учитывать производительность, гибкость и сложность реализации.

5. **Участники (Participants)**  
   Шаблон описывает роли объектов и классов, участвующих в его реализации. Например, в шаблоне "Наблюдатель" (Observer) есть два участника: "Наблюдатель" и "Субъект".

6. **Применимость (Applicability)**  
   Описание контекста, в котором шаблон лучше всего подходит для использования. Это помогает разработчикам определить, в каких ситуациях шаблон решает проблемы наилучшим образом и где его следует избегать.

7. **Структура (Structure)**  
   Диаграмма классов или объектов, которая иллюстрирует связи и взаимодействия между компонентами шаблона. Это визуальное представление помогает лучше понять, как функционирует шаблон.

## Заключение

Эти характеристики позволяют точно описать шаблоны проектирования, сделать их легко узнаваемыми и применимыми в реальных проектах. Понимание этих аспектов помогает разработчикам эффективно выбирать и использовать шаблоны для решения конкретных задач.

# 3. Назовите три основные группы паттернов

Шаблоны проектирования (паттерны) делятся на три основные группы, каждая из которых ориентирована на решение конкретного типа проблем в разработке программного обеспечения. Эти группы известны как **порождающие**, **структурные** и **поведенческие** паттерны.

## 1. Порождающие паттерны (Creational Patterns)

Порождающие паттерны сосредоточены на управлении процессом создания объектов. Они помогают абстрагировать процесс инстанцирования и сделать его более гибким, контролируя создание объектов таким образом, чтобы они соответствовали требованиям системы.

### Примеры:
- **Singleton** — гарантирует, что у класса будет только один экземпляр, и предоставляет глобальную точку доступа к нему.
- **Factory Method** — определяет интерфейс для создания объектов, но позволяет подклассам изменять тип создаваемого объекта.
- **Abstract Factory** — предоставляет интерфейс для создания семейств взаимосвязанных объектов без указания их конкретных классов.
- **Builder** — разделяет создание сложного объекта от его представления, чтобы один и тот же процесс мог создавать разные представления.
- **Prototype** — создает новые объекты путем копирования существующих объектов (прототипов).

## 2. Структурные паттерны (Structural Patterns)

Структурные паттерны помогают организовать классы и объекты в более крупные структуры, обеспечивая гибкость и эффективность системы. Эти паттерны фокусируются на компоновке объектов и классов, предоставляя возможность более удобно интегрировать различные компоненты системы.

### Примеры:
- **Adapter** — позволяет объектам с несовместимыми интерфейсами работать вместе, выступая в роли посредника.
- **Bridge** — разделяет абстракцию и реализацию так, чтобы они могли изменяться независимо.
- **Composite** — позволяет группировать объекты в древовидные структуры для представления иерархий типа "часть-целое".
- **Decorator** — динамически добавляет новые обязанности объекту, не изменяя его класс.
- **Facade** — предоставляет упрощенный интерфейс к сложной системе или набору интерфейсов.
- **Proxy** — создает заместителя для другого объекта, чтобы контролировать доступ к нему.

## 3. Поведенческие паттерны (Behavioral Patterns)

Поведенческие паттерны описывают способы взаимодействия между объектами и управления потоком данных в системе. Эти паттерны сосредоточены на том, как объекты взаимодействуют друг с другом, передают информацию и контролируют выполнение действий.

### Примеры:
- **Observer** — определяет зависимость типа "один ко многим", чтобы при изменении состояния одного объекта автоматически уведомлялись и обновлялись все зависимые объекты.
- **Strategy** — определяет семейство алгоритмов и делает их взаимозаменяемыми, позволяя менять алгоритм независимо от клиентов, которые его используют.
- **Command** — инкапсулирует запрос как объект, позволяя параметризовать клиентов с запросами, очередями или логами запросов.
- **State** — позволяет объекту изменять поведение при изменении его внутреннего состояния.
- **Chain of Responsibility** — передает запрос по цепочке обработчиков, где каждый обработчик решает, обработать запрос или передать его дальше.

## Заключение

Эти три группы паттернов помогают решать различные задачи на этапе проектирования: от управления созданием объектов (порождающие) до организации структуры (структурные) и взаимодействия объектов (поведенческие).

# 4. Расскажите про паттерн Одиночка (Singleton)

**Паттерн Singleton (Одиночка)** — это порождающий паттерн проектирования, который гарантирует, что у класса будет только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру. Основная цель паттерна — предотвратить создание более одного объекта класса, контролируя процесс инстанцирования.

## Основные характеристики Singleton

1. **Один экземпляр класса:** Паттерн гарантирует, что за всё время работы программы будет создан только один экземпляр данного класса.
2. **Глобальная точка доступа:** Этот экземпляр доступен в любой части программы через статический метод, обычно называемый `getInstance()`.
3. **Ленивая инициализация (опционально):** Объект может быть создан при первом обращении к нему, что позволяет избежать ненужного создания объекта до его реального использования.

## Пример реализации Singleton

### Реализация с ленивой инициализацией

```java
public class Singleton {
    // Приватное статическое поле, содержащее единственный экземпляр
    private static Singleton instance;

    // Приватный конструктор, чтобы предотвратить создание объектов извне
    private Singleton() {}

    // Публичный метод для получения единственного экземпляра класса
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton(); // Ленивая инициализация
        }
        return instance;
    }

    // Пример метода класса
    public void showMessage() {
        System.out.println("Hello, Singleton!");
    }
}
```

### Использование Singleton:

```java
public class Main {
    public static void main(String[] args) {
        Singleton singleton = Singleton.getInstance();
        singleton.showMessage();
    }
}
```

### Ожидаемый вывод:

```
Hello, Singleton!
```

## Потокобезопасная реализация Singleton

В многопоточных средах могут возникать проблемы с конкурентным доступом к методу `getInstance()`. Чтобы избежать этого, можно использовать синхронизацию или другие механизмы контроля доступа.

### Потокобезопасная реализация:

```java
public class ThreadSafeSingleton {
    private static ThreadSafeSingleton instance;

    private ThreadSafeSingleton() {}

    public static synchronized ThreadSafeSingleton getInstance() {
        if (instance == null) {
            instance = new ThreadSafeSingleton();
        }
        return instance;
    }
}
```

### Реализация с двойной проверкой блокировки (Double-checked locking):

```java
public class DoubleCheckedLockingSingleton {
    private static volatile DoubleCheckedLockingSingleton instance;

    private DoubleCheckedLockingSingleton() {}

    public static DoubleCheckedLockingSingleton getInstance() {
        if (instance == null) {
            synchronized (DoubleCheckedLockingSingleton.class) {
                if (instance == null) {
                    instance = new DoubleCheckedLockingSingleton();
                }
            }
        }
        return instance;
    }
}
```

### Примечания:
- **volatile** гарантирует, что изменения в переменной будут видны всем потокам.
- **Синхронизация** необходима для корректной работы в многопоточной среде.

## Преимущества Singleton

- **Контроль доступа:** Гарантия наличия единственного экземпляра класса.
- **Экономия ресурсов:** Если объект тяжёлый, его создание откладывается до первого вызова.
- **Глобальная доступность:** Лёгкий доступ к объекту в любом месте программы.

## Недостатки Singleton

- **Сложности с тестированием:** Трудно тестировать классы, зависящие от Singleton, так как его трудно заменять мок-объектами.
- **Проблемы с многопоточностью:** В незащищённых реализациях могут возникнуть гонки потоков при одновременном создании объекта.
- **Превращение в глобальную переменную:** Singleton может злоупотребляться для создания глобальных объектов, что нарушает инкапсуляцию.

## Заключение

Singleton является эффективным решением для создания единственного экземпляра объекта, но в многопоточной среде следует учитывать вопросы потокобезопасности.

# 5. Расскажите про паттерн Строитель (Builder)

**Строитель (Builder)** — это порождающий паттерн проектирования, который используется для пошагового конструирования сложных объектов. Он позволяет создавать объект, не заставляя клиентский код заботиться о деталях его создания, и предоставляет гибкость в сборке объекта за счет разделения процесса на этапы.

## Основные характеристики паттерна Строитель

1. **Пошаговая сборка объектов**: Процесс создания объекта разбит на этапы, и каждый этап может вызываться отдельно.
2. **Разделение конструкции и представления**: Строитель отделяет логику построения объекта от его конечного представления.
3. **Гибкость**: Позволяет создавать разные представления объекта, используя один и тот же процесс строительства.
4. **Необязательные параметры**: Удобно, если объект содержит множество опциональных параметров.

## Пример реализации паттерна Builder в Java

Рассмотрим класс `Person`, у которого много полей. Для создания объекта с определенными комбинациями полей можно использовать паттерн Строитель.

```java
public class Person {
    private final String firstName;
    private final String lastName;
    private final int age;
    private final String address;

    // Приватный конструктор
    private Person(Builder builder) {
        this.firstName = builder.firstName;
        this.lastName = builder.lastName;
        this.age = builder.age;
        this.address = builder.address;
    }

    // Статический класс Builder
    public static class Builder {
        private String firstName;
        private String lastName;
        private int age;
        private String address;

        public Builder setFirstName(String firstName) {
            this.firstName = firstName;
            return this;
        }

        public Builder setLastName(String lastName) {
            this.lastName = lastName;
            return this;
        }

        public Builder setAge(int age) {
            this.age = age;
            return this;
        }

        public Builder setAddress(String address) {
            this.address = address;
            return this;
        }

        // Метод для создания объекта Person
        public Person build() {
            return new Person(this);
        }
    }

    @Override
    public String toString() {
        return "Person{" +
                "firstName='" + firstName + '\'' +
                ", lastName='" + lastName + '\'' +
                ", age=" + age +
                ", address='" + address + '\'' +
                '}';
    }
}
```

### Пример использования:

```java
public class Main {
    public static void main(String[] args) {
        Person person = new Person.Builder()
                .setFirstName("John")
                .setLastName("Doe")
                .setAge(30)
                .setAddress("123 Main St")
                .build();

        System.out.println(person);
    }
}
```

### Ожидаемый вывод:

```
Person{firstName='John', lastName='Doe', age=30, address='123 Main St'}
```

## Особенности паттерна Builder

1. **Читаемость**: Код становится более читаемым, когда нужно задать несколько параметров. Например, мы можем задать только нужные параметры, не указывая все сразу.
2. **Гибкость**: Строитель может применяться для создания разных конфигураций объекта без необходимости создавать множество конструкторов.
3. **Неизменяемость**: Объект может быть неизменяемым, поскольку его поля задаются только при создании с помощью Строителя, а сам объект становится неизменяемым после создания.

## Когда использовать паттерн Строитель

- Когда объект содержит множество опциональных параметров.
- Когда необходимо обеспечить пошаговую сборку объекта.
- Когда нужно избежать большого числа перегруженных конструкторов.

## Заключение

Паттерн Строитель удобен при создании сложных объектов с множеством параметров, обеспечивая читабельный и гибкий подход к их созданию.

# 6. Расскажите про паттерн Фабричный метод (Factory Method)

**Фабричный метод (Factory Method)** — это порождающий паттерн проектирования, который предоставляет интерфейс для создания объектов, позволяя подклассам изменять тип создаваемых объектов. Паттерн решает проблему, когда код не должен напрямую зависеть от конкретных классов создаваемых объектов.

## Основные характеристики паттерна Фабричный метод

1. **Инкапсуляция создания объекта**: Фабричный метод скрывает детали создания объекта, позволяя изменять тип создаваемого объекта, не меняя клиентский код.
2. **Полиморфизм**: Создание объектов делегируется подклассам, что позволяет создавать разные объекты через общий интерфейс.
3. **Расширяемость**: Новые типы объектов могут быть добавлены без изменения существующего клиентского кода.

## Пример реализации паттерна Factory Method в Java

Предположим, у нас есть интерфейс `Transport`, который представляет различные виды транспорта. Каждая фабрика будет создавать конкретный вид транспорта.

### Интерфейс `Transport`:

```java
public interface Transport {
    void deliver();
}
```

### Классы, реализующие интерфейс `Transport`:

```java
public class Truck implements Transport {
    @Override
    public void deliver() {
        System.out.println("Доставка по земле на грузовике.");
    }
}

public class Ship implements Transport {
    @Override
    public void deliver() {
        System.out.println("Доставка по морю на корабле.");
    }
}
```

### Абстрактный класс `TransportFactory` с фабричным методом:

```java
public abstract class TransportFactory {
    // Фабричный метод
    public abstract Transport createTransport();

    // Общий метод
    public void planDelivery() {
        Transport transport = createTransport();
        transport.deliver();
    }
}
```

### Конкретные фабрики:

```java
public class TruckFactory extends TransportFactory {
    @Override
    public Transport createTransport() {
        return new Truck();
    }
}

public class ShipFactory extends TransportFactory {
    @Override
    public Transport createTransport() {
        return new Ship();
    }
}
```

### Пример использования:

```java
public class Main {
    public static void main(String[] args) {
        TransportFactory factory = new TruckFactory();
        factory.planDelivery(); // Доставка по земле на грузовике.

        factory = new ShipFactory();
        factory.planDelivery(); // Доставка по морю на корабле.
    }
}
```

### Ожидаемый вывод:

```
Доставка по земле на грузовике.
Доставка по морю на корабле.
```

## Преимущества паттерна Фабричный метод

1. **Ослабленная связь**: Клиентский код не зависит от конкретных классов, создаваемых объектов. Это упрощает замену или добавление новых типов объектов.
2. **Расширяемость**: Подклассы могут определять собственные типы создаваемых объектов, что делает код гибким и расширяемым.
3. **Упрощение поддержки**: Можно легко добавлять новые продукты (объекты) без изменения клиентского кода.

## Недостатки паттерна Фабричный метод

1. **Усложнение кода**: В некоторых случаях добавление новых классов (фабрик) может увеличивать сложность архитектуры.
2. **Множественные подклассы**: При каждом новом типе объекта необходимо создавать новые фабрики, что может привести к множеству подклассов.

## Когда использовать паттерн Фабричный метод

- Когда нужно отделить процесс создания объектов от их использования.
- Когда программа должна создавать объекты разных классов, но без жесткой привязки к их типам.
- Когда нужно обеспечить полиморфное создание объектов.

## Заключение

Фабричный метод — это полезный паттерн для создания объектов, когда их точный тип должен определяться подклассами, обеспечивая гибкость и расширяемость архитектуры.

# 7. Расскажите про паттерн Абстрактная фабрика (Abstract Factory)

**Абстрактная фабрика (Abstract Factory)** — это порождающий паттерн проектирования, который предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не указывая их конкретные классы. Основное отличие от Фабричного метода заключается в том, что Абстрактная фабрика позволяет создавать семейства объектов, обеспечивая согласованность создаваемых объектов в рамках одной фабрики.

## Основные характеристики паттерна Абстрактная фабрика

1. **Создание семейств объектов**: Паттерн позволяет создавать наборы взаимосвязанных объектов (например, кнопка и окно для конкретной ОС).
2. **Абстракция над процессом создания объектов**: Клиентский код работает с интерфейсами или абстрактными классами, а конкретные классы определяются фабриками.
3. **Полиморфизм и инкапсуляция**: Клиентский код ничего не знает о конкретных классах создаваемых объектов.

## Пример использования Абстрактной фабрики

Предположим, мы создаем интерфейс для приложения, которое должно поддерживать разные операционные системы: Windows и macOS. Мы хотим создать семейство графических компонентов (кнопка и чекбокс), которые соответствуют стилю каждой ОС.

### Интерфейсы для компонентов:

```java
public interface Button {
    void paint();
}

public interface Checkbox {
    void paint();
}
```

### Реализация для Windows:

```java
public class WindowsButton implements Button {
    @Override
    public void paint() {
        System.out.println("Рисуем кнопку в стиле Windows.");
    }
}

public class WindowsCheckbox implements Checkbox {
    @Override
    public void paint() {
        System.out.println("Рисуем чекбокс в стиле Windows.");
    }
}
```

### Реализация для macOS:

```java
public class MacOSButton implements Button {
    @Override
    public void paint() {
        System.out.println("Рисуем кнопку в стиле macOS.");
    }
}

public class MacOSCheckbox implements Checkbox {
    @Override
    public void paint() {
        System.out.println("Рисуем чекбокс в стиле macOS.");
    }
}
```

### Абстрактная фабрика для создания компонентов:

```java
public interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}
```

### Конкретные фабрики:

```java
public class WindowsFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new WindowsButton();
    }

    @Override
    public Checkbox createCheckbox() {
        return new WindowsCheckbox();
    }
}

public class MacOSFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new MacOSButton();
    }

    @Override
    public Checkbox createCheckbox() {
        return new MacOSCheckbox();
    }
}
```

### Клиентский код:

```java
public class Application {
    private Button button;
    private Checkbox checkbox;

    public Application(GUIFactory factory) {
        button = factory.createButton();
        checkbox = factory.createCheckbox();
    }

    public void paint() {
        button.paint();
        checkbox.paint();
    }
}
```

### Использование:

```java
public class Main {
    public static void main(String[] args) {
        GUIFactory factory;
        String os = "Windows"; // Можно менять на "MacOS"

        if (os.equals("Windows")) {
            factory = new WindowsFactory();
        } else {
            factory = new MacOSFactory();
        }

        Application app = new Application(factory);
        app.paint();
    }
}
```

### Ожидаемый вывод для Windows:

```
Рисуем кнопку в стиле Windows.
Рисуем чекбокс в стиле Windows.
```

### Ожидаемый вывод для macOS:

```
Рисуем кнопку в стиле macOS.
Рисуем чекбокс в стиле macOS.
```

## Преимущества паттерна Абстрактная фабрика

1. **Инкапсуляция создания семейства объектов**: Позволяет создавать связанные объекты через общий интерфейс, скрывая конкретные реализации.
2. **Гарантия совместимости продуктов**: Объекты, созданные одной фабрикой, всегда совместимы между собой.
3. **Легкость замены семейств объектов**: Можно легко менять создаваемые объекты, не изменяя клиентский код.

## Недостатки паттерна Абстрактная фабрика

1. **Сложность при добавлении новых продуктов**: Для добавления нового типа продуктов необходимо изменять все фабрики, что может усложнять поддержку.
2. **Множество классов**: В зависимости от количества семейств объектов и продуктов, может потребоваться большое количество классов, что увеличивает сложность кода.

## Когда использовать Абстрактную фабрику

- Когда системе нужно работать с несколькими семействами взаимосвязанных объектов (например, графический интерфейс для разных операционных систем).
- Когда создание объектов должно быть скрыто от клиентского кода, а объекты должны быть созданы через общий интерфейс.
- Когда необходимо обеспечить согласованность продуктов внутри одного семейства (например, элементы GUI одной ОС).
