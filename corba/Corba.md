# CORBA и распределенные системы

Источник: https://pro-prof.com/forums/topic/java_parallel_6

**CORBA (Common Object Request Broker Architecture – общая архитектура брокера объектных запросов)** – это технологический стандарт написания распределённых приложений, продвигаемый консорциумом OMG (Object Management Group – группа управления объектами) и соответствующая ему информационная технология.

Технология CORBA является механизмом для интеграции изолированных информационных систем, который даёт возможность программам, написанным на разных языках программирования и работающим на разных узлах сети, взаимодействовать друг с другом, так как если бы они находились в адресном пространстве одного процесса.

Основой технологии CORBA является **ORB (Object Request Broker – брокер объектных запросов)** – «объектная шина», которая позволяет передавать сообщения от одного объекта к другому. Она может быть реализована в виде библиотеки, специального сетевого сервиса, объектно-ориентированной СУБД или уже быть включенной в операционную систему. ORB дает возможность объектам, которых он обслуживает, не задумываться о том, где находятся объекты, которым передаются сообщения. Кроме того, он скрывает все детали реализации объектов, оставляя видимыми только их интерфейсы.

## 1 Ключевые понятия технологии CORBA

### 1.1 Объекты по значению

Помимо удалённых объектов в CORBA 3.0 определено понятие объект по значению. Код методов таких объектов по умолчанию выполняется локально. Если объект по значению был получен с удалённой стороны, то необходимый код должен либо быть заранее известен обеим сторонам, либо быть динамически загружен. Чтобы это было возможно, запись, определяющая такой объект, содержит поле Code Base – список URL, откуда может быть загружен код.

У объекта по значению могут также быть и удалённые методы, поля, которые передаются вместе с самим объектом. Поля, в свою очередь также могут быть такими объектами, формируя таким образом списки, деревья или произвольные графы. Объекты по значению могут иметь иерархию классов, включая абстрактные и множественное наследование.

### 1.2 Компонентная модель CORBA (CCM)

**Компонентная модель CORBA (CCM)** — дополнение к семейству определений CORBA.

CCM была введена, начиная с CORBA 3.0, и описывает стандартный каркас приложения для компонент CORBA. CCM построена под сильным влиянием Enterprise JavaBeans (EJB) и фактически является его независимым от языка расширением. CCM предоставляет абстракцию сущностей, которые могут предоставлять и получать сервисы через чётко определённые именованные интерфейсы порты.

Модель CCM предоставляет контейнер компонентов, в котором могут поставляться программные компоненты. Контейнер предоставляет набор служб, которые может использовать компонент. Эти службы включают (но не ограничены) службу уведомления, авторизации, персистентности (способности объекта существовать дольше процесса, создавшего его) и управления транзакциями. Это наиболее часто используемые распределённым приложением службы. Перенося реализацию этих сервисов от необходимости реализации самим приложением в функциональность контейнера приложения, можно значительно снизить сложность реализации собственно компонентов.

### 1.3 Общий протокол межброкерного взаимодействия (GIOP)

**GIOP** – абстрактный протокол в стандарте CORBA, обеспечивающий интероперабельность (способность к взаимодействию) брокеров. Стандарты, связанные с протоколом выпускает Object Management Group (OMG). Архитектура GIOP включает несколько конкретных протоколов:

1. **Internet InterORB Protocol (IIOP) (Межброкерный протокол для Интернет)** — протокол для организации взаимодействия между различными брокерами, опубликованный консорциумом OMG. IIOP используется GIOP в среде интернет, и обеспечивает отображение сообщений между GIOP и слоем TCP/IP.
2. **SSL InterORB Protocol (SSLIOP)** — IIOP поверх SSL (Secure Sockets Layer — уровень защищённых сокетов), поддерживает шифрование и аутентификацию.
3. **HyperText InterORB Protocol (HTIOP)** — IIOP поверх протокола HTTP.

### 1.4 Ссылка на объект (Corba Location)

**CorbaLoc (англ. Corba Location)** — является строковой ссылкой на объект технологии CORBA, подобной URL.
Все реализации CORBA должны поддерживать как минимум два варианта OMG URL: corbaloc: и corbaname:. Их назначение в том, чтобы предоставить человеку способ читать и редактировать ссылку, посредством которой можно получить ссылку на объект CORBA.

**Пример corbaloc:**
corbaloc::160.45.110.41:38693/StandardNS/NameServer-POA/_root

Реализация CORBA может предоставлять поддержку форматов **«http:», «ftp:» и «file:»**. Назначение этих форматов в том, чтобы указать способ получить строковое представление ссылки на объект CORBA.

### 1.5 Список брокеров (CORBA ORBs)

* **Borland Enterprise Server, VisiBroker Ed** — CORBA 2.6-совместимый коммерческий ORB от Borland, поддерживает Java и C++.
* **MICO** — свободный (LGPL – GNU Lesser General Public License – Стандартная общественная лицензия ограниченного применения GNU) ORB с поддержкой C++.
* **omniORB** — свободный (LGPL) ORB для C++ и Python.
* **ORBit2** — свободный (LGPL) ORB для C, C++ и Python.
* **JacORB** — свободный (LGPL) ORB, написан на Java.
* **TAO** — The ACE (англ. Adaptive Communication Enviroment – адаптивная коммуникационная среда) ORB, открытый ORB для C++.
* **Orbacus** — коммерческий ORB для C++, Java от IONA Technologies.
* **Orbix** — коммерческий ORB от IONA Technologies.
* **PolyORB** — ORB от AdaCore для языка программирования Ada. Есть как свободная, так и коммерческая версии.

## 2 Создание распределённого приложения на базе CORBA

Процесс разработки распределенного приложения на языке Java с использованием технологии CORBA включает в себя следующие шаги:

* Описание интерфейса удаленного объекта с помощью языка **IDL (Interface Definition Langauge – язык описания интерфейсов)**.
* Обработка описания интерфейса на языке IDL компилятором **idlj**. В результате будут сгенерированы файлы, содержащие Java-версию описания интерфейса и код классов для программных прослоек, называемых **stub** на стороне клиента и **skeleton** (каркас) на стороне сервера. Эти программные прослойки обеспечивают подключение к ORB.
* Программирование **сервера**. Его код включает в себя сгенерированный компилятором idlj код skeleton’ов, реализацию методов интерфейса, код запуска ORB и ожидания обращений от клиентов.
* Программирование **клиента** на основе сгенерированного компилятором idlj кода stub’ов. Клиент стартует свой ORB, отыскивает нужный ему сервер, используя службу имен, получает ссылку на удаленный объект и вызывает его методы.
* Запуск приложения путем последовательного старта службы имен, сервера и клиента.

## 3 Пример простого приложения клиент-сервер

Ниже приведена последовательность действий по разработке клиент-серверного приложения, в котором сервер предоставляет возможность клиенту вывести на экран текстовую строку «Hello, World!» и завершить работу ORB.

### 3.1 Создание интерфейса на языке IDL

**IDL** – декларативный язык для формального описания интерфейсов взаимодействия клиентов и серверов в распределенных приложениях. IDL не привязан к какому-либо языку программирования, но для большинства современных языков программирования существуют спецификации, определяющие правила трансляции конструкций IDL в конструкции этих языков.
Ниже приведен пример описания интерфейса для приложения Hello (в файле Hello.idl каталога приложения).

``` idl
module HelloApp {
  interface Hello {
    string sayHello();
    oneway void shutdown();
  };
};
```

Конструкция `module` определяет пространство имен, в котором будут существовать включенные в нее интерфейсы. Эта конструкция по своему смыслу близка понятию «пакет» (package) языка Java.

Конструкция `interface` определяет программный интерфейс, с помощью которого объекты общаются друг с другом. В этом интерфейсы языков IDL и Java аналогичны.

В теле конструкции `interface` объявляются операции, которые должен быть способен выполнять сервер по запросу клиента. Операции языка IDL соответствуют методам языка Java.

В результате компиляции будет создан пакет с именем HelloApp (имя из конструкции module) в каталоге `Hello`, содержащий 6 файлов: 
`Hello.java`, `HelloPOA.java`, `_HelloStub.java`, `HelloOperations.java`, `HelloHelper.java`, `HelloHolder.java`.

* `Hello.java` содержит код Java-интерфейса Hello, сгенерированный из IDL-интерфейса. Интерфейс `Hello` расширяет интерфейсы HelloOperations, `org.omg.CORBA.Object и org.omg.CORBA.portable.IDLEntity`
* `HelloOperations.java` содержит код Java-интерфейса `HelloOperations`, объявляющего два метода `sayHello()` и `shutdown()`, соответствующих операциям языка IDL. Интерфейс `HelloOperations` используется stub’ами клиентов и skeleton’ами серверов.
* `HelloPOA.java` содержит код абстрактного класса `HelloPOA`, расширяющего класс `org.omg.PortableServer.Servant` и реализующего интерфейсы `HelloApp.HelloOperations`, `org.omg.CORBA.portable.InvokeHandler`. Класс `HelloPOA` является skeleton’ом и обеспечивает базовую функциональность CORBA для сервера.
* `_HelloStub.java` содержит код класса `_HelloStub`, расширяющего класс org.omg.`CORBA.portable.ObjectImpl` и реализующего интерфейс `HelloApp.Hello`. Этот класс играет роль stub’а и обеспечивает базовую функциональность CORBA для клиента. 
* `HelloHelper.java` содержит код класса `HelloHelper`, обеспечивающего вспомогательную функциональность. Например, метод `narrow()` этого класса необходим для преобразования объектных ссылок (`object references`) CORBA, используемых для идентификации объектов, к типам, принятым в Java. Этот класс реализует чтение/запись данных различного типа в потоки CORBA. 
* `HelloHolder.java` содержит код финального класса HelloHolder, реализующего интерфейс `org.omg.CORBA.portable.Streamable`. Этот класс включает открытую переменную типа `Hello`. Для аргументов типа `out` и `inout` операций языка IDL в этом классе выполняются преобразования, соответствующие семантике аргументов методов языка Java. Класс `Holder` обращается к методам класса `Helper` для выполнения операций чтения/записи в потоки CORBA.

### 3.2 Создание серверной части приложения

Серверная часть приложения состоит из двух классов: собственно сервера и серванта (`servant`). Сервант (назовем его `HelloImpl`) реализует IDL-интерфейс Hello, при этом каждая сущность IDL-интерфейса `Hello` реализуется сущностью класса `HelloImpl`. Сервант является подклассом класса `HelloPOA`, описание которого сгенерировано компилятором idlj.

Сервант содержит по одному методу для каждой IDL-операции (в нашем примере это методы `sayHello()` и `shutdown()`). Методы серванта являются «обычными» методами Java, все вспомогательные операции (общение с ORB, приведение аргументов и результатов и т.п.) выполняются каркасом.
Класс сервера содержит метод `main()`, который выполняет следующие задачи:

* создание и инициализация экземпляра ORB;
* получение доступа к корневому объекту POA и активизация POAManager;
* создание экземпляра серванта и информирование ORB о нем;
* получение доступа к объекту CORBA в пространстве имен, в котором необходимо зарегистрировать новый объект CORBA;
* получение корневого пространства имен;
* регистрация нового объекта в пространстве имен под именем «Hello»;
* ожидание вызова нового объекта со стороны клиентов.

Ниже представлен пример кода (в файле `HelloServer.java` каталога `Hello`) серверной части приложения.

``` java
// ----- Импорт всех необходимых пакетов -----
// Пакет, сгенерированный компилятором idlj
import HelloApp.*;
// Пакет, необходимый для использования службы имен
import org.omg.CosNaming.*;
// Пакет, содержащий специальные исключения, генерируемые службой имен
import org.omg.CosNaming.NamingContextPackage.*;
// Пакет, содержащий классы, необходимые любому приложению CORBA
import org.omg.CORBA.*;
// Пакеты, содержащие классы, реализующие модель наследования переносимых серверов
import org.omg.PortableServer.*;
import org.omg.PortableServer.POA;
// Пакет, содержащий классы, необходимые для инициализации ORB
import java.util.Properties;
// ----- Реализация класса-серванта -----
// Сервант HelloImpl является подклассом класса HelloPOA и 
// наследует всю функциональность CORBA, сгенерированную для 
// него компилятором
class HelloImpl extends HelloPOA {
    private ORB orb;
    // Необходима для хранения текущего ORB (используется в методе 
    // shutdown)
    public void setORB(ORB orb_val) {
        orb = orb_val;
    }
    public String sayHello() {
        return "\nHello, world !!\n";
    }
    public void shutdown() {
        // Использует метод org.omg.CORBA.ORB.shutdown(boolean) для
        // завершения ORB, false означает, что завершение
        // должно быть немедленным
        orb.shutdown(false);
    }
}
// ----- Реализация класса-сервера -----
public class HelloServer {
    // Сервер создает один или несколько объектов-сервантов.
    // Сервант наследует интерфейсу, сгенерированному компилятором
    // idlj, и реально выполняет все операции этого интерфейса.
    public static void main(String args[]) {
        try {
            // Создаем и инициализируем экземпляр ORB
            String[] par = {
                "-ORBInitialPort",
                "2050",
                "-ORBInitialHost",
                "localhost"
            };
            ORB orb = ORB.init(par, null);
            // Получаем доступ к Root POA и активируем POAManager
            POA rootpoa = POAHelper.narrow(orb.resolve_initial_references("RootPOA"));
            rootpoa.the_POAManager().activate();
            // Создаем объект сервант и регистрируем в нем объект ORB
            HelloImpl helloImpl = new HelloImpl();
            helloImpl.setORB(orb);
            // Получаем доступ к объекту серванта
            org.omg.CORBA.Object ref = rootpoa.servant_to_reference(helloImpl);
            Hello href = HelloHelper.narrow(ref);
            // Получаем корневой контекст именования
            org.omg.CORBA.Object objRef = orb.resolve_initial_references("NameService");
            // NamingContextExt является частью спецификации 
            // Interoperable Naming Service (INS)
            NamingContextExt ncRef = NamingContextExtHelper.narrow(objRef);
            // Связывание идентификатора "Hello" и объекта серванта
            String name = "Hello";
            NameComponent path[] = ncRef.to_name(name);
            ncRef.rebind(path, href);
            System.out.println("HelloServer готов и ждет обращений …");
            // Ожидание обращений клиентов
            orb.run();
        } catch (Exception e) {
            System.err.println("ОШИБКА: " + e); // Выводим сообщение 
            // об ошибке
            e.printStackTrace(System.out); // Выводим содержимое 
            // стека вызовов
        };
        System.out.println("HelloServer работу завершил …");
    }
}
```

Далее следуют пояснения отдельных строк кода.

``` java
ORB orb = ORB.init(par, null);
```

Любому серверу CORBA необходим локальный объект ORB. Каждый сервер создает экземпляр ORB и регистрирует в нем свои объекты-серванты, дабы ORB мог найти объекты при получении соответствующих запросов.

``` java
rootpoa.the_POAManager().activate();
```

Операция `activate()` делает состояние POAManager’а активным, заставляя ассоциированные с ним POA начать обработку запросов. Каждый объект POA ассоциирован с одним объектом POAManager, но объект POAManager может быть ассоциирован с несколькими объектами POA.

``` java
org.omg.CORBA.Object objRef = rb.resolve_initial_references("NameService");
```

Для обеспечения доступа клиентов к операциям серванта сервер использует службу имен под названием Common Object Services (COS). Серверу необходим доступ к службе имен для того, чтобы он мог опубликовать ссылки на объекты, реализующие различные интерфейсы. В настоящее время реализовано 2 типа службы имен: `tnameserv` (временная) и `orbd` (временная и постоянная). Наш пример использует orbd. Аргумент в виде «NameService» понимается службами имен обоих типов, при этом для `orbd` он означает постоянный режим, а для `tnameserv` — временный. Для приведения orbd во временный режим необходимо использовать «TNameService».

``` java
NamingContextExt ncRef = NamingContextExtHelper.narrow(objRef);
```

**objRef** — «первородный» (исходный) объект CORBA. Для его использования в качестве объекта `NamingContextExt` необходимо «преобразование типа», выполняемое методом `narrow()` вспомогательного класса `NamingContextExtHelper`, сгенерированного компилятором `idlj`. После этого объект `ncRef` применяется для доступа к службе имен и регистрации в ней сервера.

### 3.3 Создание клиентской части приложения

Клиент объекта имеет доступ к объектной ссылке и вызывает операции объекта. Клиент знает только логическую структуру объекта в соответствии с его интерфейсом и может наблюдать за поведением объекта через вызовы методов.

Ниже представлен пример кода (в файле `HelloClient.java` каталога `Hello`) клиентской части приложения.

``` java
import HelloApp.*;
import org.omg.CosNaming.*;
import org.omg.CosNaming.NamingContextPackage.*;
import org.omg.CORBA.*;
public class HelloClient {
    static Hello helloImpl;
    public static void main(String args[]) {
        try {
            // Создание и инициализация ORB
            String[] par = {
                "-ORBInitialPort",
                "2050",
                "-ORBInitialHost",
                "localhost"
            };
            ORB orb = ORB.init(par, null);
            // Получение корневого контекста именования
            org.omg.CORBA.Object objRef = orb.resolve_initial_references("NameService");
            // NamingContextExt является частью спецификации
            // Interoperable Naming Service (INS)
            NamingContextExt ncRef = NamingContextExtHelper.narrow(objRef);
            // Получение доступа к серверу по его имени
            String name = "Hello";
            helloImpl = HelloHelper.narrow(ncRef.resolve_str(name));
            System.out.println("Получен доступ к объекту " + helloImpl);
            System.out.println(helloImpl.sayHello());
            helloImpl.shutdown();
        } catch (Exception e) {
            System.out.println("ОШИБКА : " + e);
            e.printStackTrace(System.out);
        }
    }
}
```

Прежде чем запустить на выполнение сервер, и затем клиент распределённого приложения, необходимо запустить сервис именования командой orbd из набора jdk 7 (в нашем случае был использован jdk1.7.0_09) с параметрами порта и хоста.

Например:

```bash
>orbd -ORBInitialPort 2050 -ORBInitialHost localhost
```
