# 1. Чем отличается процесс от потока?

Процессы и потоки (или нити) — это фундаментальные концепции в операционных системах и программировании, которые используются для выполнения программ. Несмотря на то, что оба они представляют собой единицы выполнения, между ними есть несколько ключевых различий.

## 1. **Определение**

- **Процесс (Process):**
  - Это независимая программа, выполняющаяся в операционной системе. Каждый процесс имеет свое собственное адресное пространство (виртуальную память), ресурсы (например, открытые файлы, файловые дескрипторы), и обычно выполняется независимо от других процессов.
  - Процессы могут взаимодействовать друг с другом через механизмы межпроцессного взаимодействия (IPC), такие как очереди сообщений, пайпы или сокеты, но это взаимодействие обычно сложнее и медленнее, чем взаимодействие между потоками.

- **Поток (Thread):**
  - Поток — это наименьшая единица выполнения в процессе. Потоки внутри одного процесса разделяют одно и то же адресное пространство и ресурсы процесса, такие как память, открытые файлы и другие данные. Однако каждый поток имеет собственный стек, регистры процессора и программный счетчик (PC).
  - Потоки часто называют "легковесными процессами" из-за их меньших накладных расходов и быстрой смены контекста по сравнению с процессами.

## 2. **Изоляция и безопасность**

- **Процесс:**
  - Процессы изолированы друг от друга, что означает, что ошибки в одном процессе (например, некорректный доступ к памяти) обычно не влияют на другие процессы. Это изоляция делает процессы безопаснее, но также увеличивает накладные расходы на взаимодействие между ними.
  
- **Поток:**
  - Потоки внутри одного процесса не изолированы друг от друга и разделяют память и ресурсы. Это делает их более эффективными в плане взаимодействия, но также приводит к рискам, связанным с параллельным доступом к общим данным (например, условия гонки или мертвая блокировка).

## 3. **Создание и управление**

- **Процесс:**
  - Создание нового процесса обычно требует значительных системных ресурсов. Время на создание процесса включает копирование данных процесса (например, адресного пространства), создание таблиц страниц, инициализацию дескрипторов и т.д.
  - Управление процессами также связано с большими накладными расходами, поскольку операционная система должна поддерживать полную информацию о каждом процессе.

- **Поток:**
  - Создание потока требует меньше ресурсов, так как потоки разделяют память и ресурсы процесса. Создание и переключение контекста потоков происходит быстрее, чем у процессов.
  - Потоки более гибкие для выполнения задач, требующих параллелизма и многозадачности в пределах одного процесса.

## 4. **Пример использования**

- **Процесс:**
  - Каждый процесс может быть использован для выполнения отдельной программы или независимой задачи, например, веб-браузер, текстовый редактор, серверная служба.
  - Процессы полезны, когда нужно выполнить задачи в строгой изоляции друг от друга, например, запуск разных приложений в операционной системе.

- **Поток:**
  - Потоки часто используются внутри одного процесса для выполнения параллельных задач. Например, в веб-браузере один поток может заниматься загрузкой веб-страниц, другой — рендерингом, третий — обработкой пользовательского ввода.
  - Потоки полезны, когда нужно выполнять несколько задач одновременно в одном и том же контексте, например, многопоточная обработка данных.

## 5. **Переключение контекста**

- **Процесс:**
  - Переключение контекста между процессами включает переключение всего состояния процесса, включая его адресное пространство, регистры процессора, таблицы страниц и т.д. Это достаточно ресурсоемкий процесс.

- **Поток:**
  - Переключение контекста между потоками включает только переключение регистров и стека, поскольку потоки разделяют адресное пространство процесса. Это делает переключение контекста между потоками быстрее и менее затратным по ресурсам.

## Заключение

- Процесс — это более изолированная и независимая единица выполнения, которая требует больше ресурсов для создания и управления, но обеспечивает безопасность и изоляцию.
- Поток — это легковесная единица выполнения, которая делит ресурсы с другими потоками в том же процессе, что делает его более эффективным для многозадачности, но требует более тщательной синхронизации для предотвращения проблем, связанных с параллельным доступом к общим данным.

# 2. В чем разница между классом Thread и интерфейсом Runnable? В каких случаях предпочтительно использовать Thread, а в каких Runnable?

В Java классы `Thread` и интерфейс `Runnable` играют важную роль при работе с многопоточностью. Хотя оба способа позволяют выполнять код в отдельном потоке, они имеют свои особенности и предназначены для разных сценариев использования.

## 1. **Основные различия между `Thread` и `Runnable`**

### **Класс `Thread`:**

- **Наследование:** `Thread` — это класс, который расширяет (`extends`) класс `Object` и реализует интерфейс `Runnable`. Когда вы создаете класс, который наследуется от `Thread`, он становится полноценным потоком.
  
- **Наследование от другого класса:** В Java вы можете наследоваться только от одного класса, поэтому если ваш класс уже наследуется от другого класса, вы не сможете наследоваться от `Thread`.

- **Прямое управление потоком:** Класс `Thread` предоставляет больше возможностей для управления потоком, таких как методы `start()`, `sleep()`, `join()`, `interrupt()`, `setPriority()` и т.д. 

### **Интерфейс `Runnable`:**

- **Интерфейс:** `Runnable` — это функциональный интерфейс с единственным методом `run()`, который должен быть реализован в классе, чтобы его объекты могли быть выполнены в потоке. 

- **Наследование от другого класса:** Использование `Runnable` позволяет вам наследоваться от другого класса, так как вы реализуете интерфейс, а не наследуетесь от класса. Это особенно полезно, если ваш класс уже расширяет другой класс, но вы хотите добавить возможность работы в потоке.

- **Разделение логики и потока:** Использование `Runnable` отделяет логику задачи (то, что выполняется в методе `run()`) от механизма управления потоком, что делает код более гибким и модульным.

## 2. **Примеры использования**

### **Класс `Thread`:**

Пример создания потока, наследуясь от класса `Thread`:

```java
class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("MyThread is running");
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start(); // Запуск потока
    }
}
```

### **Интерфейс `Runnable`:**

Пример создания потока с использованием интерфейса `Runnable`:

```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("MyRunnable is running");
    }
}

public class Main {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start(); // Запуск потока
    }
}
```

## 3. **Когда использовать `Thread`, а когда `Runnable`?**

### **Использование `Thread`:**

- **Простые сценарии:** Если вы создаете простое многопоточное приложение, и ваш класс не требует наследования от другого класса, вы можете напрямую наследоваться от `Thread`.
- **Контроль над потоком:** Если вам нужно больше контроля над потоком, например, изменение его приоритета, использование методов `interrupt()`, `join()`, и т.д., вы можете использовать класс `Thread`.

### **Использование `Runnable`:**

- **Гибкость и модульность:** Если ваш класс уже наследуется от другого класса или если вы хотите отделить логику выполнения от управления потоком, лучше использовать `Runnable`. Это обеспечивает большую гибкость и делает код более читаемым и поддерживаемым.
- **Переиспользование кода:** Если вам нужно повторно использовать класс в различных контекстах, где многопоточность является опцией, а не необходимостью, `Runnable` предпочтительнее, так как его можно использовать с разными механизмами выполнения потоков, такими как `ThreadPoolExecutor`.
- **Работа с пулами потоков:** В современных приложениях часто используются пулы потоков, такие как `ExecutorService`, которые принимают объекты `Runnable`. Использование `Runnable` в таких сценариях позволяет вам лучше управлять ресурсами и масштабируемостью приложения.

## 4. **Заключение**

- **Используйте `Thread`,** когда вам нужно быстро создать поток без сложных требований к наследованию и управлению потоками.
- **Используйте `Runnable`,** когда вам нужно больше гибкости, модульности, или если ваш класс уже наследуется от другого класса. `Runnable` также предпочтителен для работы с пулами потоков и другими высокоуровневыми механизмами управления потоками.

Оба подхода имеют свои плюсы и минусы, и выбор между ними зависит от архитектуры и требований вашего приложения.

# 3. Что представляет собой монитор? Как в Java реализован монитор?

## Что такое монитор?

Монитор — это механизм синхронизации, который используется для управления доступом к общим ресурсам в многопоточных программах. Он обеспечивает взаимное исключение (mutex), гарантируя, что только один поток может выполнять определенный блок кода или метод в любой момент времени. Это помогает предотвратить состояния гонки и другие проблемы, связанные с параллельным доступом к общим данным.

## Как работает монитор?

Монитор включает в себя три основных компонента:

1. **Взаимное исключение (Mutex):** Обеспечивает доступ к общему ресурсу только одному потоку за раз.
2. **Состояние (Condition):** Определяет, какие потоки могут быть запущены, и управляет порядком их запуска.
3. **Ожидание и уведомление (Wait/Notify):** Потоки могут быть приостановлены и ожидать определенного условия, и затем уведомлены, когда это условие выполнено.

Когда поток входит в монитор (т.е. пытается выполнить синхронизированный код), он блокирует монитор. Если монитор уже занят другим потоком, поток будет помещен в очередь ожидания, пока монитор не освободится.

## Мониторы в Java

В Java монитор реализован на уровне языка через ключевые слова и встроенные методы:

### 1. **Ключевое слово `synchronized`:**

- **Синхронизированный метод:** В Java любой метод может быть объявлен как `synchronized`. Это означает, что только один поток может одновременно выполнять этот метод для данного экземпляра объекта. Внутри метода монитор захватывается при его вызове и освобождается, когда метод завершает выполнение.

  ```java
  public synchronized void synchronizedMethod() {
      // Код, который может выполнять только один поток за раз
  }
  ```

- **Синхронизированный блок:** Более тонкий контроль над синхронизацией обеспечивается с помощью синхронизированных блоков, которые позволяют синхронизировать доступ к определенному коду внутри метода, используя монитор определенного объекта.

  ```java
  public void someMethod() {
      synchronized(this) {  // Монитор захватывается для текущего объекта
          // Код, который может выполнять только один поток за раз
      }
  }
  ```

  Можно синхронизировать блоки кода с использованием монитора любого объекта:

  ```java
  public void someMethod() {
      Object lock = new Object();
      synchronized(lock) {
          // Код защищен монитором объекта lock
      }
  }
  ```

### 2. **Методы `wait()`, `notify()`, `notifyAll()`:**

Эти методы определены в классе `Object` и позволяют потокам взаимодействовать друг с другом через монитор.

- **`wait()`:** Вызывает ожидание потока, освобождая монитор до тех пор, пока другой поток не вызовет `notify()` или `notifyAll()` на том же мониторе.
  
  ```java
  synchronized(lock) {
      lock.wait();  // Поток освобождает монитор и ждет уведомления
  }
  ```

- **`notify()`:** Будит один поток, ожидающий на мониторе. Тот поток, который первым захватит монитор после пробуждения, продолжит выполнение.

  ```java
  synchronized(lock) {
      lock.notify();  // Уведомляем один поток, ожидающий на мониторе lock
  }
  ```

- **`notifyAll()`:** Будит все потоки, ожидающие на мониторе, но только один из них сможет захватить монитор и продолжить выполнение, остальные снова будут ждать.

  ```java
  synchronized(lock) {
      lock.notifyAll();  // Уведомляем все потоки, ожидающие на мониторе lock
  }
  ```

### 3. **Статическая синхронизация:**

Вы также можете синхронизировать доступ к статическим методам и блокам кода. В этом случае монитор захватывается на уровне класса, а не экземпляра объекта.

```java
public static synchronized void staticSynchronizedMethod() {
    // Синхронизировано для всего класса
}

public static void someMethod() {
    synchronized(MyClass.class) {
        // Синхронизированный блок на уровне класса
    }
}
```

## Пример использования монитора в Java

Рассмотрим пример, где несколько потоков пытаются увеличить общий счетчик:

```java
public class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}

public class Main {
    public static void main(String[] args) {
        Counter counter = new Counter();

        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        };

        Thread thread1 = new Thread(task);
        Thread thread2 = new Thread(task);

        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Final count: " + counter.getCount());
    }
}
```

В этом примере методы `increment()` и `getCount()` синхронизированы, что гарантирует, что доступ к счетчику будет корректно управляться мониторами, и оба потока не смогут одновременно изменить значение счетчика.

## Заключение

Монитор в Java обеспечивает механизм синхронизации, предотвращающий одновременный доступ нескольких потоков к критическим секциям кода. Использование ключевого слова `synchronized` и методов `wait()`, `notify()`, `notifyAll()` позволяет легко управлять многопоточными программами, минимизируя риск возникновения ошибок, связанных с параллельным доступом к общим ресурсам.

# 4. Что такое синхронизация? Какие методы синхронизации существуют в Java?

## Что такое синхронизация?

Синхронизация — это механизм, который используется в многопоточном программировании для управления доступом к общим ресурсам. Она гарантирует, что только один поток может одновременно получить доступ к определенному блоку кода или объекту, тем самым предотвращая ошибки, такие как состояния гонки, когда несколько потоков пытаются одновременно изменить один и тот же ресурс.

Синхронизация необходима для обеспечения корректного выполнения программы, когда несколько потоков работают с общими данными. Без синхронизации могут возникнуть непредсказуемые ошибки, такие как некорректные данные, повреждение состояния объекта или нарушения последовательности выполнения кода.

## Методы синхронизации в Java

В Java существует несколько способов достижения синхронизации:

### 1. **Ключевое слово `synchronized`**

#### a. **Синхронизированные методы**

Метод может быть объявлен как `synchronized`, чтобы гарантировать, что он может быть выполнен только одним потоком в одно и то же время. 

- **Синхронизированные экземплярные методы:**
  
  Когда метод синхронизирован на уровне объекта (`this`), только один поток может выполнить его для данного экземпляра класса. Если другой поток пытается выполнить любой другой синхронизированный метод того же экземпляра, он будет блокирован, пока первый поток не завершит выполнение метода.

  ```java
  public class Example {
      public synchronized void synchronizedMethod() {
          // Код, который может выполнить только один поток в данный момент
      }
  }
  ```

- **Синхронизированные статические методы:**

  Синхронизированный статический метод блокирует доступ ко всем другим синхронизированным статическим методам класса. Это происходит потому, что монитор захватывается на уровне класса, а не конкретного объекта.

  ```java
  public class Example {
      public static synchronized void staticSynchronizedMethod() {
          // Код, который может выполнить только один поток для всего класса
      }
  }
  ```

#### b. **Синхронизированные блоки**

Синхронизированный блок дает более гибкий контроль над синхронизацией, позволяя синхронизировать доступ только к определенным частям метода. Это позволяет улучшить производительность, так как не весь метод блокируется.

- **Синхронизация на уровне объекта:**
  
  В этом случае монитор захватывается для конкретного объекта.

  ```java
  public void someMethod() {
      synchronized(this) {
          // Код внутри блока защищен от одновременного доступа
      }
  }
  ```

- **Синхронизация на уровне класса или другого объекта:**

  Можно использовать любой объект в качестве монитора для синхронизации, например, строку, объект другого класса или статический объект.

  ```java
  public void someMethod() {
      Object lock = new Object();
      synchronized(lock) {
          // Доступ к этому блоку кода синхронизирован на объекте lock
      }
  }
  ```

### 2. **Библиотека `java.util.concurrent`**

Java предоставляет высокоуровневые механизмы синхронизации в библиотеке `java.util.concurrent`, которые предлагают большую гибкость и возможности.

#### a. **ReentrantLock**

`ReentrantLock` — это альтернатива синхронизированным блокам и методам. Он предоставляет больше возможностей, таких как возможность проверки состояния блокировки, опциональная попытка блокировки и возможность справедливой блокировки.

```java
import java.util.concurrent.locks.ReentrantLock;

public class Example {
    private final ReentrantLock lock = new ReentrantLock();

    public void method() {
        lock.lock();  // Захват блокировки
        try {
            // Код, который должен быть синхронизирован
        } finally {
            lock.unlock();  // Обязательно освобождаем блокировку в блоке finally
        }
    }
}
```

#### b. **ReadWriteLock**

`ReadWriteLock` позволяет разделить блокировку на чтение и запись. Это полезно, когда несколько потоков могут безопасно читать данные одновременно, но только один поток должен иметь возможность записывать данные.

```java
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class Example {
    private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();

    public void readMethod() {
        rwLock.readLock().lock();  // Захват блокировки на чтение
        try {
            // Код для чтения данных
        } finally {
            rwLock.readLock().unlock();  // Освобождение блокировки на чтение
        }
    }

    public void writeMethod() {
        rwLock.writeLock().lock();  // Захват блокировки на запись
        try {
            // Код для записи данных
        } finally {
            rwLock.writeLock().unlock();  // Освобождение блокировки на запись
        }
    }
}
```

#### c. **CountDownLatch**

`CountDownLatch` позволяет одному или нескольким потокам ждать завершения набора операций, выполняемых другими потоками. Этот класс полезен для координации выполнения потоков.

```java
import java.util.concurrent.CountDownLatch;

public class Example {
    private final CountDownLatch latch = new CountDownLatch(3);

    public void someMethod() throws InterruptedException {
        latch.await();  // Ожидание до тех пор, пока счетчик не станет 0
    }

    public void taskCompleted() {
        latch.countDown();  // Уменьшение счетчика на 1
    }
}
```

#### d. **CyclicBarrier**

`CyclicBarrier` позволяет группе потоков ожидать друг друга до тех пор, пока все не достигнут определенной точки. Полезно для задач, где необходимо координировать выполнение группы потоков.

```java
import java.util.concurrent.CyclicBarrier;

public class Example {
    private final CyclicBarrier barrier = new CyclicBarrier(3, () -> System.out.println("All threads reached the barrier"));

    public void someMethod() throws InterruptedException {
        barrier.await();  // Ожидание всех потоков перед продолжением
    }
}
```

### 3. **Волатильные переменные (`volatile`)**

Переменная, помеченная ключевым словом `volatile`, гарантирует, что изменения переменной, произведенные одним потоком, будут немедленно видны другим потокам. Это снижает вероятность работы с устаревшими данными в многопоточном окружении, но не обеспечивает полной синхронизации.

```java
public class Example {
    private volatile boolean flag = true;

    public void someMethod() {
        while (flag) {
            // Выполняется пока flag равен true
        }
    }

    public void stopMethod() {
        flag = false;  // Поток, выполняющий someMethod, видит это изменение немедленно
    }
}
```

### 4. **Методы `wait()`, `notify()`, `notifyAll()`**

Эти методы, определенные в классе `Object`, позволяют потокам взаимодействовать через мониторы:

- **`wait()`:** Ожидание освобождения монитора.
- **`notify()`:** Пробуждение одного ожидающего потока.
- **`notifyAll()`:** Пробуждение всех ожидающих потоков.

Пример использования:

```java
public class Example {
    private final Object lock = new Object();

    public void waitingMethod() throws InterruptedException {
        synchronized (lock) {
            lock.wait();  // Ожидание уведомления
        }
    }

    public void notifyingMethod() {
        synchronized (lock) {
            lock.notify();  // Уведомление одного потока
        }
    }
}
```

## Заключение

Синхронизация в Java необходима для безопасного доступа к общим ресурсам в многопоточных приложениях. Java предоставляет различные методы для достижения синхронизации, начиная с базовых (`synchronized`) и заканчивая более продвинутыми механизмами из пакета `java.util.concurrent`, такими как `ReentrantLock`, `CountDownLatch`, и другие. Выбор подходящего метода зависит от конкретной задачи и уровня контроля, необходимого для обеспечения корректной работы программы.

# 5. Какое значение имеет ключевое слово `synchronized`? Где и для каких целей его следует использовать?

## Значение ключевого слова `synchronized`

Ключевое слово `synchronized` в Java используется для обеспечения синхронизации потоков, что предотвращает одновременное выполнение критических секций кода несколькими потоками. Это ключевое слово гарантирует, что только один поток может выполнить синхронизированный блок кода или метод в конкретный момент времени, тем самым защищая общие ресурсы от одновременного доступа и предотвращая состояния гонки.

## Где и для каких целей следует использовать `synchronized`?

### 1. **Синхронизация методов**

Когда метод объявляется как `synchronized`, монитор (блокировка) захватывается для объекта, на котором вызывается этот метод (если метод нестатический), или для всего класса (если метод статический). Это гарантирует, что только один поток может выполнить этот метод для данного объекта или класса.

#### a. **Нестатические методы:**

Если метод нестатический, синхронизация происходит на уровне конкретного экземпляра объекта. Это означает, что два потока не могут одновременно выполнять синхронизированный метод для одного и того же объекта, но они могут выполнять этот метод для разных объектов.

```java
public class Example {
    public synchronized void syncMethod() {
        // Только один поток может одновременно выполнять этот метод
    }
}
```

#### b. **Статические методы:**

Если метод статический, синхронизация происходит на уровне класса. Это означает, что все потоки синхронизируются на уровне класса, и только один поток может одновременно выполнять этот метод для всех экземпляров этого класса.

```java
public class Example {
    public static synchronized void syncStaticMethod() {
        // Только один поток может выполнять этот метод для всех экземпляров класса
    }
}
```

### 2. **Синхронизация блоков кода**

Синхронизированные блоки дают возможность синхронизировать только часть метода, что позволяет повысить производительность, так как не весь метод блокируется, а только его критическая секция.

#### a. **Синхронизация на уровне объекта:**

Вы можете синхронизировать доступ к определенному коду, используя в качестве монитора конкретный объект. В этом случае монитор захватывается только на время выполнения синхронизированного блока.

```java
public void someMethod() {
    synchronized(this) {  // Блокировка на уровне текущего объекта
        // Код, защищенный от одновременного доступа
    }
}
```

#### b. **Синхронизация на уровне класса или другого объекта:**

Синхронизировать можно не только на уровне текущего объекта (`this`), но и на уровне любого другого объекта, который используется в качестве монитора. Это полезно, если требуется синхронизация на определенных объектах или группах объектов.

```java
public void someMethod() {
    Object lock = new Object();
    synchronized(lock) {  // Блокировка на уровне объекта lock
        // Код, защищенный от одновременного доступа
    }
}
```

### 3. **Использование `synchronized` для предотвращения состояний гонки**

Состояния гонки (race conditions) возникают, когда несколько потоков одновременно изменяют общие данные, и результат выполнения зависит от порядка их выполнения. Использование `synchronized` предотвращает такие проблемы, обеспечивая последовательный доступ к ресурсам.

#### Пример:

Рассмотрим пример с общим счетчиком, который увеличивается несколькими потоками:

```java
public class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}
```

Здесь оба метода синхронизированы, что гарантирует корректную работу счетчика при одновременном доступе из нескольких потоков.

### 4. **Когда следует использовать `synchronized`?**

#### a. **При работе с общими ресурсами:**

Если несколько потоков работают с общими переменными, объектами или другими ресурсами, `synchronized` помогает защитить эти ресурсы от одновременного доступа и некорректного изменения.

#### b. **Для защиты критических секций:**

Когда часть кода может повлиять на общие данные и должна быть выполнена атомарно, т.е. как единое целое без прерываний другими потоками, синхронизация необходима.

#### c. **Для обеспечения корректности данных:**

Синхронизация обеспечивает согласованность и целостность данных, предотвращая одновременные изменения и некорректное состояние объектов.

### 5. **Проблемы, связанные с использованием `synchronized`**

#### a. **Заблокированность (Deadlock):**

Если два или более потоков ожидают захвата ресурсов, удерживаемых друг другом, это может привести к состоянию взаимной блокировки (deadlock). Поэтому при использовании `synchronized` нужно тщательно продумывать порядок захвата блокировок.

#### b. **Снижение производительности:**

Чрезмерное использование `synchronized` может привести к снижению производительности, так как потоки будут часто блокироваться и ждать освобождения ресурсов.

## Заключение

Ключевое слово `synchronized` в Java является мощным инструментом для управления многопоточностью. Оно позволяет избежать состояний гонки и обеспечивает корректный и согласованный доступ к общим ресурсам в многопоточных приложениях. Однако его использование требует тщательного планирования, чтобы избежать таких проблем, как взаимные блокировки и снижение производительности.
